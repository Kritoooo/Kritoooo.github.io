<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>手写线程池</title>
      <link href="/2024/03/26/%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/03/26/%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h1><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>当我们使用线程的时候就去创建一个线程，这样的实现虽然很简便，但是在并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束的时候，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>线程池的作用就是复用线程，当一个线程执行完任务后，并不被销毁，而是可以继续执行其他任务。</p><p>线程池的组成：</p><ol><li>任务队列，存储需要处理的任务，由工作的线程来处理这些任务。<ul><li>通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除。</li><li>已处理的任务会被从任务队列中删除。</li><li>线程池的使用者，调用线程池函数往任务队列中添加任务的线程（生产者线程）。</li></ul></li><li>工作的线程（任务队列任务的消费者），N个<ul><li>线程池中维护了一定数量的工作线程，他们不停的读任务队列，从里边取出任务并处理。</li><li>工作的线程相当于是任务队列的消费者角色。</li><li>如果任务队列为空，工作的线程会被阻塞</li><li>如果阻塞后有了新的任务，由生产者将阻塞解除。</li></ul></li><li>管理者线程，1个<ul><li>它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测<ul><li>当任务过多的时候，可以适当创建一些新的工作线程。</li><li>当任务过少的时候，可以适当销毁一些工作线程。</li></ul></li></ul></li></ol><h2 id="ThreadPool-c"><a href="#ThreadPool-c" class="headerlink" title="ThreadPool.c"></a>ThreadPool.c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    Task* taskQ;</span><br><span class="line">    <span class="type">int</span> queueCapacity;</span><br><span class="line">    <span class="type">int</span> queueSize;</span><br><span class="line">    <span class="type">int</span> queueFront;</span><br><span class="line">    <span class="type">int</span> queueRear;</span><br><span class="line">    </span><br><span class="line">    <span class="type">pthread_t</span> managerID; </span><br><span class="line">    <span class="type">pthread_t</span>* threadIDs; <span class="comment">// 线程ID数组，用来存储工作的线程ID</span></span><br><span class="line">    <span class="type">int</span> minNum; <span class="comment">// 最小线程数</span></span><br><span class="line">    <span class="type">int</span> maxNum; <span class="comment">// 最大线程数</span></span><br><span class="line">    <span class="type">int</span> busyNum; <span class="comment">// 忙的线程数</span></span><br><span class="line">    <span class="type">int</span> liveNum; <span class="comment">// 存活的线程个数</span></span><br><span class="line">    <span class="type">int</span> exitNum; <span class="comment">// 要销毁的线程个数</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexPool; <span class="comment">// 线程池锁</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutexBusy; <span class="comment">// busyNum变量锁</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notFull; <span class="comment">// 任务队列是否满了</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> notEmpty; <span class="comment">// 任务队列是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> shutdown; <span class="comment">// 是否要销毁整个线程池，销毁为1，不销毁为0</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务，包含两个成员，分别是线程需要执行的函数，已经函数携带的参数列表。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*function) (<span class="type">void</span>* arg);</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;Task;</span><br></pre></td></tr></table></figure><h3 id="threadPoolCreate"><a href="#threadPoolCreate" class="headerlink" title="threadPoolCreate"></a>threadPoolCreate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool* <span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ThreadPool));</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;threadIDs = (<span class="type">pthread_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*max);</span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;threadIDs == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadIDs fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threadIDs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*max);</span><br><span class="line">        pool-&gt;minNum = min;</span><br><span class="line">        pool-&gt;maxNum = max;</span><br><span class="line">        pool-&gt;busyNum = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;liveNum = min;</span><br><span class="line">        pool-&gt;exitNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;pool-&gt;mutexPool, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_mutex_init(&amp;pool-&gt;mutexBusy, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notEmpty, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">            pthread_cond_init(&amp;pool-&gt;notFull, <span class="literal">NULL</span>)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;mutex or condition init fail...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;taskQ = (Task*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Task)*queueSize);</span><br><span class="line">        pool-&gt;queueCapacity = queueSize;</span><br><span class="line">        pool-&gt;queueSize = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueFront = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queueRear = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;shutdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pthread_create(&amp;pool-&gt;managerID, <span class="literal">NULL</span>, manager, pool);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; min; i ++) &#123;</span><br><span class="line">            pthread_create(&amp;pool-&gt;threadIDs[i],<span class="literal">NULL</span>, worker, pool);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;threadIDs) <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    <span class="keyword">if</span> (pool &amp;&amp; pool-&gt;taskQ) <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    <span class="keyword">if</span> (pool) <span class="built_in">free</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addTask"><a href="#addTask" class="headerlink" title="addTask"></a>addTask</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(ThreadPool *pool, <span class="type">void</span> (*func)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">while</span>(pool-&gt;queueSize == pool-&gt;queueCapacity) &#123;</span><br><span class="line">        <span class="comment">// 阻塞生产者线程</span></span><br><span class="line">        pthread_cond_wait(&amp;pool-&gt;notFull, &amp;pool-&gt;mutexPool);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].function = func;</span><br><span class="line">    pool-&gt;taskQ[pool-&gt;queueRear].arg = arg;</span><br><span class="line">    pool-&gt;queueRear = (pool-&gt;queueRear + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">    pool-&gt;queueSize ++;</span><br><span class="line"></span><br><span class="line">    pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取BusyNum和liveNum"><a href="#获取BusyNum和liveNum" class="headerlink" title="获取BusyNum和liveNum"></a>获取BusyNum和liveNum</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(ThreadPool *pool)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(ThreadPool *pool)</span> &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="type">int</span> aliveNum = pool-&gt;liveNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">    <span class="keyword">return</span> aliveNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="threadPoolDestroy"><a href="#threadPoolDestroy" class="headerlink" title="threadPoolDestroy"></a>threadPoolDestroy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(ThreadPool *pool)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    pool-&gt;shutdown = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 收回管理者线程</span></span><br><span class="line">    pthread_join(pool-&gt;managerID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 唤醒阻塞的消费者</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;liveNum; ++i) &#123;</span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放堆内存</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;taskQ) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;taskQ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pool-&gt;threadIDs) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threadIDs);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexPool);</span><br><span class="line">    pthread_mutex_destroy(&amp;pool-&gt;mutexBusy);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notEmpty);</span><br><span class="line">    pthread_cond_destroy(&amp;pool-&gt;notFull);</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;queueSize == <span class="number">0</span> &amp;&amp; !pool-&gt;shutdown) &#123;</span><br><span class="line">            <span class="comment">// 阻塞</span></span><br><span class="line">            pthread_cond_wait(&amp;pool-&gt;notEmpty, &amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否要销毁线程</span></span><br><span class="line">            <span class="keyword">if</span>(pool-&gt;exitNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;exitNum--;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;liveNum &gt; pool-&gt;minNum) &#123;</span><br><span class="line">                    pool-&gt;liveNum--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">                    threadExit(pool);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;shutdown) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            threadExit(pool);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Task task;</span><br><span class="line">        task.function = pool-&gt;taskQ[pool-&gt;queueFront].function;</span><br><span class="line">        task.arg = pool-&gt;taskQ[pool-&gt;queueFront].arg;</span><br><span class="line">        pool-&gt;queueFront = (pool-&gt;queueFront + <span class="number">1</span>) % pool-&gt;queueCapacity;</span><br><span class="line">        pool-&gt;queueSize--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 唤醒生产者</span></span><br><span class="line">        pthread_cond_signal(&amp;pool-&gt;notFull);</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld start working... \n&quot;</span>, pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum ++;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        task.function(task.arg);</span><br><span class="line">        <span class="built_in">free</span>(task.arg);</span><br><span class="line">        task.arg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %ld end working... \n&quot;</span>, pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        pool-&gt;busyNum --;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*) arg;</span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown) &#123;</span><br><span class="line">        <span class="comment">// 每三秒检测一次</span></span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">        <span class="type">int</span> queueSize = pool-&gt;queueSize;</span><br><span class="line">        <span class="type">int</span> liveNum = pool-&gt;liveNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;mutexBusy);</span><br><span class="line">        <span class="type">int</span> busyNum = pool-&gt;busyNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;mutexBusy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加线程</span></span><br><span class="line">        <span class="comment">// 任务个数&gt;存活的线程个数 &amp;&amp; 存活线程数&lt;最大线程数</span></span><br><span class="line">        <span class="keyword">if</span>(queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;maxNum) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maxNum &amp;&amp; counter &lt; NUMBER &amp;&amp; pool-&gt;liveNum &lt; pool-&gt;maxNum; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;threadIDs[i] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    pthread_create(&amp;pool-&gt;threadIDs[i], <span class="literal">NULL</span>, worker, pool);</span><br><span class="line">                    counter ++;</span><br><span class="line">                    pool-&gt;liveNum++;</span><br><span class="line">                                        </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 销毁线程</span></span><br><span class="line">        <span class="comment">// 忙的线程*2 &lt; 存活的线程数 &amp;&amp; 存活的线程 &gt; 最小线程数</span></span><br><span class="line">        <span class="keyword">if</span> (busyNum*<span class="number">2</span> &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;minNum) &#123;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            pool-&gt;exitNum = NUMBER;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;mutexPool);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 唤醒阻塞的工作线程，让其自杀</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUMBER; i ++) &#123; </span><br><span class="line">                pthread_cond_signal(&amp;pool-&gt;notEmpty); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="threadExit"><a href="#threadExit" class="headerlink" title="threadExit"></a>threadExit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(ThreadPool* pool)</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid = pthread_self();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;maxNum; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;threadIDs[i] == tid) &#123;</span><br><span class="line">            pool-&gt;threadIDs[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;threadExit() called, %ld exiting...\n&quot;</span>, tid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="threadpool-h"><a href="#threadpool-h" class="headerlink" title="threadpool.h"></a>threadpool.h</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadPool</span> <span class="title">ThreadPool</span>;</span></span><br><span class="line"><span class="comment">// 创建线程池并初始化</span></span><br><span class="line">ThreadPool* <span class="title function_">threadPoolCreate</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max, <span class="type">int</span> queueSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁线程池</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolDestroy</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给线程池添加任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">threadPoolAdd</span><span class="params">(ThreadPool* pool, <span class="type">void</span>(*func)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池中工作的线程的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolBusyNum</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"><span class="comment">// 获取线程池中活着的线程的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadPoolAliveNum</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">worker</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="type">void</span>* <span class="title function_">manager</span><span class="params">(<span class="type">void</span>* arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">threadExit</span><span class="params">(ThreadPool* pool)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="测试线程池"><a href="#测试线程池" class="headerlink" title="测试线程池"></a>测试线程池</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">taskFunc</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span>*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread is working, number = %d, tid = %ld\n&quot;</span>, num, pthread_self());</span><br><span class="line">    usleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    ThreadPool* pool = threadPoolCreate(<span class="number">3</span>, <span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span>* num = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        *num = i + <span class="number">100</span>;</span><br><span class="line">        threadPoolAdd(pool, taskFunc, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    threadPoolDestroy(pool);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行</p><p><img src="/pic/image-20240327130325254.png" alt="image-20240327130325254"></p><p>运行结果</p><p><img src="/pic/image-20240327130241273.png" alt="image-20240327130241273"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 多线程 </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/2024/03/15/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2024/03/15/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h2><p>对于多个线程访问共享资源（临界资源）出现数据混乱的问题，需要进行线程同步。常见的线程同步方式有四种：互斥锁、读写锁、条件变量、信号量。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>通过互斥锁可以锁定一个代码块，被锁定的代码块，所有线程只能顺序执行（不能并行）。这样多线程访问共享资源数据混乱的问题就得到解决，需要付出的代价是执行效率降低，因为从并行处理退化到了串行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex; <span class="comment">//保存了锁的状态信息与线程ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// restrict 只有这个关键字修饰的指针可以访问指向的内存地址，其他指针不行。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放互斥锁资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>mutex：互斥锁变量的地址</li><li>attr：互斥锁的属性，一般使用默认即可，指定为NULL</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span><br></pre></td></tr></table></figure><p>该函数被调用时，首先会判断参数mutex互斥锁中的状态是否为锁定：</p><ul><li>如果没有被锁定，这个线程可以加锁成功，锁中会记录是哪个线程加锁成功了。</li><li>如果被锁定了，其他线程加锁就失败了，这些线程都会阻塞在这里。</li><li>当这把锁被解开之后，这些阻塞在锁上的线程就接触阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><ul><li>如果这把锁没有被锁定，线程加锁成功</li><li>如果锁被锁定了，调用这个函数加锁的线程不会被阻塞，加锁失败直接返回错误号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对互斥锁解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><p>利用互斥锁进行线程同步</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcA_num</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread A, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">funcB_num</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread B, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> agrc, <span class="type">const</span> <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p1, <span class="literal">NULL</span>, funcA_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2, <span class="literal">NULL</span>, funcB_num, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2, <span class="literal">NULL</span>); </span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，成功完成了100次计数。</p><p><img src="/./pic/image-20240315154936287.png" alt="image-20240315154936287"></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>当多个线程访问临界资源时，如果加锁不当，就会造成死锁。死锁造成的后果是，所有线程都被阻塞，并且线程的阻塞时无法解开的。</p><p>造成死锁的场景：</p><ul><li><p>加锁后忘记解锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void func() &#123;</span><br><span class="line">for (int i = 0; i &lt; 6; i ++) &#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">// 忘记解锁</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">for(int i = 0; i &lt; 6; i ++) &#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">if(...) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重复加锁，造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++) &#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">... ...</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcA</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++) &#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">funcB</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i ++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        ...</span><br><span class="line">        funcA();</span><br><span class="line">        ...</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环</p></li></ul><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁是互斥锁的升级版，在做读操作的时候可以提高程序的执行效率，如果所有的线程都是做读操作，那么读是并行，但是使用互斥锁，读操作也是串行的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure><p>锁中记录的信息：</p><ul><li>锁的状态：锁定&#x2F;打开</li><li>锁定的是什么操作：读操作&#x2F;写操作（锁定了读操作，需要先解锁才能去锁定写操作，反之亦然。</li><li>哪个线程进行的加锁</li></ul><p>读写锁的特点：</p><ul><li>使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，读锁是共享的。</li><li>使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，写锁是独占的。</li><li>写锁比读锁的优先级高。</li></ul><p>程序中所有线程都对共享资源有写也有读操作，并且对共享资源读的操作越多，读写锁更有优势。</p><h3 id="读写锁函数"><a href="#读写锁函数" class="headerlink" title="读写锁函数"></a>读写锁函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 释放读写锁占用的系统资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destory</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>rwlock：读写锁的地址，传出参数</li><li>attr：读写锁属性，一般使用默认属性，指定为NULL</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对读写锁加读锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数时，如果读写锁打开，则加锁成功；如果读写锁已经锁定为读，则仍然可以加锁成功；如果读写锁已经锁定了写操作，则会被阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加锁失败时不会被阻塞。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用这个函数尝试加锁，如果加锁失败返回错误号，且线程不会被阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在程序中对读写锁加写锁，锁定写操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><p>调用时，如果读写锁打开，那么加锁成功；如果读写锁已经被锁定，则会被阻塞。</p><h3 id="读写锁使用"><a href="#读写锁使用" class="headerlink" title="读写锁使用"></a>读写锁使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 50</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">read_num</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++) &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread read, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(rand()%<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">write_num</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX; i ++) &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        <span class="type">int</span> cur = number;</span><br><span class="line">        cur ++;</span><br><span class="line">        number = cur;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Thread write, id = %lu, number = %d\n&quot;</span>, pthread_self(), number);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1[<span class="number">5</span>], p2[<span class="number">3</span>];</span><br><span class="line">    pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_create(&amp;p1[i], <span class="literal">NULL</span>, read_num, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">        pthread_create(&amp;p2[i], <span class="literal">NULL</span>, write_num, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++) &#123;</span><br><span class="line">        pthread_join(p2[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_join(p1[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./pic/image-20240317144148391.png" alt="image-20240317144148391"></p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>一般用于处理生产者和消费者模型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br></pre></td></tr></table></figure><p>被条件变量阻塞的线程的线程信息会被记录到这个变量中，以便在解除阻塞的时候使用。</p><h3 id="条件变量函数"><a href="#条件变量函数" class="headerlink" title="条件变量函数"></a>条件变量函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁并释放</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>cond：条件变量的地址</li><li>attr：条件变量属性，一般使用默认属性，NULL。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程阻塞函数，哪个线程调用这个函数，哪个线程就会被阻塞。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示的时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec; <span class="comment">// 秒</span></span><br><span class="line">    <span class="type">long</span> tv_nsec; <span class="comment">// 纳秒</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将线程阻塞一定的时间长度，时间达到之后，线程就解除阻塞了。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params"><span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure><p>struct timespec 的赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> mytim = time(<span class="literal">NULL</span>); <span class="comment">// 当前总秒数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">tmsp</span>;</span></span><br><span class="line">tmsp.tv_nsec = <span class="number">0</span>;</span><br><span class="line">tmsp.tv_sec = time(<span class="literal">NULL</span>) + <span class="number">100</span>; <span class="comment">//线程阻塞100s</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程，至少有一个被解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程，被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><h3 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p>使用条件变量实现生产者和消费者模型，生产者有5个，往链表头部添加节点，消费者也有5个，删除链表头部的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        newNode-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者, id：%ld, number：%d\n&quot;</span>,pthread_self(),newNode-&gt;number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">cosumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span>(head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 阻塞消费者线程</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者, id：%ld, number：%d\n&quot;</span>, pthread_self(), node-&gt;number);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> t1[<span class="number">5</span>], t2[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_create(&amp;t1[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_create(&amp;t2[i], <span class="literal">NULL</span>, cosumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_join(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_join(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./pic/image-20240318101142349.png" alt="image-20240318101142349"></p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="信号量函数"><a href="#信号量函数" class="headerlink" title="信号量函数"></a>信号量函数</h3><p>信号量和条件变量一样用于处理生产者和消费者模型，用于阻塞生产者线程或消费者线程的运行。信号量的类型为sem_t对应的头文件为&lt;semaphore.h&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="type">sem_t</span> sem;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 初始化信号量</span><br><span class="line">int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="line">//资源释放，线程销毁后调用</span><br><span class="line">int sem_destory(sem_t *sem);</span><br></pre></td></tr></table></figure><ul><li>参数<ul><li>sem：信号量变量地址</li><li>pshared：<ul><li>0：线程同步</li><li>非0：进程同步</li></ul></li><li>value：初始化当前信号量拥有的资源数，如果资源数为0，线程就会被阻塞了。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数被调用 sem中的资源就会被消耗一个，资源数-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>当线程调用这个函数，并且sem中的资源数&gt;0,线程不会阻塞，线程会占用sem中的一个资源，因此资源数-1，直到资源数减为0，资源被耗尽，因此线程被阻塞。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>资源被耗尽时，线程也不会阻塞，函数返回一个错误号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>使资源数+1。</p><h3 id="生产者和消费者-1"><a href="#生产者和消费者-1" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h3><p>情形一，资源总数为1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> semp;</span><br><span class="line"><span class="type">sem_t</span> semc;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;semp);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        newNode-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者, id：%ld, number：%d\n&quot;</span>,pthread_self(),newNode-&gt;number);</span><br><span class="line">        sem_post(&amp;semc);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">cosumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;semc);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者, id：%ld, number：%d\n&quot;</span>, pthread_self(), node-&gt;number);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        sem_post(&amp;semp);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    sem_init(&amp;semc,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;semp,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">pthread_t</span> t1[<span class="number">5</span>], t2[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_create(&amp;t1[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_create(&amp;t2[i], <span class="literal">NULL</span>, cosumer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_join(t1[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">        pthread_join(t2[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;semc);</span><br><span class="line">    sem_destroy(&amp;semp);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./pic/image-20240318104240968.png" alt="image-20240318104240968"></p><p>情形2，资源总数大于1时，需要和锁配合使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">producer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;semp);</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        newNode-&gt;number = rand() % <span class="number">1000</span>;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;生产者, id：%ld, number：%d\n&quot;</span>,pthread_self(),newNode-&gt;number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        </span><br><span class="line">        sem_post(&amp;semc);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">cosumer</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;semc);</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">node</span> =</span> head;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;消费者, id：%ld, number：%d\n&quot;</span>, pthread_self(), node-&gt;number);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        sem_post(&amp;semp);</span><br><span class="line">        sleep(rand()%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/./pic/image-20240318104822374.png" alt="image-20240318104822374"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群晖虚拟机安装</title>
      <link href="/2024/03/15/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2024/03/15/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="群晖虚拟机安装"><a href="#群晖虚拟机安装" class="headerlink" title="群晖虚拟机安装"></a>群晖虚拟机安装</h1><h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><p>首先在群晖套件中心下载Virtual Machine Manager</p><p><img src="/pic/image-20240228202835895.png" alt="image-20240228202835895"></p><p>然后下载你需要安装的系统镜像。博主这里需要学习linux的一些常见知识，所以打算安装Centos7和ubuntu20这两个系统。</p><p>Centos7:<a href="https://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/">centos-7.9.2009-isos-x86_64安装包下载_开源镜像站-阿里云 (aliyun.com)</a></p><p>Ubuntu20.04:<a href="https://mirrors.aliyun.com/ubuntu-releases/20.04/?spm=a2c6h.25603864.0.0.4e6b4ddafVxC0M">ubuntu-releases-20.04安装包下载_开源镜像站-阿里云 (aliyun.com)</a></p><p>下载完镜像后，上传到群晖中。</p><p>打开Virtual Machine Manager，然后点击新增。</p><p><img src="/pic/image-20240228210909220.png" alt="image-20240228210909220"></p><p>经过一系列配置后，将启动ISO文件选择为我们上传的系统镜像即可。</p><p><img src="/pic/image-20240228211013978.png" alt="image-20240228211013978"></p><p>最后启动虚拟机，进行centos系统的安装与配置即可。</p><h2 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h2><p>在同一个局域网内，我们使用另外一台电脑对群晖系统上的虚拟机进行连接。</p><p>首先，我们需要在虚拟机内安装ssh（如果没有）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><p>然后我们开启默认端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>将我框出的语句的#删掉即可，然后保存并退出。</p><p><img src="/pic/image-20240301215914743.png" alt="image-20240301215914743"></p><p>最后重启SSH服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(ubuntu) sudo service ssh restart</span><br><span class="line">(centos7) service sshd restart</span><br></pre></td></tr></table></figure><p>输入命令，查看是否成功启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status sshd.service</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240301220247107.png" alt="image-20240301220247107"></p><p>最后，我们使用本地ssh连接群晖上的虚拟机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@虚拟机ip地址</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240301220656918.png" alt="image-20240301220656918"></p><p>输入密码后即可成功连接。此方式需要虚拟机网络接口与群晖宿主机相同。</p><p><img src="/pic/image-20240301220755647.png" alt="image-20240301220755647"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> NAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程(一)</title>
      <link href="/2024/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%80/"/>
      <url>/2024/03/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h1><p>线程是轻量级的进程。操作系统会以进程为单位，分配系统资源。进程是资源分配的最小单位，线程是操作系统调度执行的最小单位。</p><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>进程有独立的地址空间，多个线程共用同一个地址空间。</p><ul><li>线程更加节省系统资源。</li><li>在一个地址空间中，每个线程都有属于自己的栈区，寄存器。</li><li>在一个地址空间中，代码段，堆区，全局数据区，文件描述符表都是线程共享的。</li></ul><p>线程是程序的最小执行单位，进程是操作系统中最小的资源分配单位。</p><p>线程的上下文切换比进程快的多。</p><p>线程更加廉价，启动速度更快，退出也快，对系统资源的冲击小。</p><p>在处理多任务程序的时候使用多线程比使用多进程要更有优势，但是线程并不是越多越好。</p><ol><li>处理复杂的算法（主要是CPU进行运算），线程的个数&#x3D;CPU的核心数。</li><li>处理IO密集型任务时，因为可以分时复用CPU时间片，所以线程个数可以略大于CPU的核心数（两倍）。</li></ol><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="线程函数"><a href="#线程函数" class="headerlink" title="线程函数"></a>线程函数</h3><p>每个线程都有一个唯一的线程ID，类型为pthread_t，是一个无符号长整形。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// 返回当前线程的线程ID</span></span><br></pre></td></tr></table></figure><p>在一个进程中调用线程创建函数，就得到一个子线程，和进程不同，需要给每一个创建出的线程指定一个处理函数，否则这个线程无法工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li>thread：传出参数；线程创建成功，会将线程ID写入到这个指针指向的内存中。</li><li>attr：线程的属性，一般情况下使用默认属性，即NULL。</li><li>start_routine：函数指针，创建出的子线程的处理动作，该函数在子线程中执行。</li><li>arg：作为实参传递到start_routine指针指向的函数内部。 </li><li>返回值：创建成功返回0，创建失败返回对应的错误号。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子线程: i = %d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程：%ld\n&quot;</span>, pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;主线程: i = %d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果。子线程还未执行，主线程就执行完毕，将资源释放掉了，所以子线程最终没有执行。</p><p><img src="/pic/image-20240313132124485.png" alt="image-20240313132124485"></p><p>在主线程中加入sleep，等待子线程执行完后，再释放资源。</p><p><img src="/pic/image-20240313132221404.png" alt="image-20240313132221404"></p><p><img src="/pic/image-20240313132321069.png" alt="image-20240313132321069"></p><h2 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h2><p>在编写多线程程序的时候，如果想要让线程退出，但是不会导致虚拟地址空间的释放，我们就可以调用线程库中的线程退出函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：线程退出时携带的数据，当前子线程的主线程会得到该数据。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;子线程: i = %d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;子线程：%ld\n&quot;</span>, pthread_self());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">pthread_t</span> tid;</span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;主线程: %ld\n&quot;</span>, pthread_self());</span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程结束后资源并未被释放，子线程继续执行完。</p><p><img src="/pic/image-20240313133206157.png" alt="image-20240313133206157"></p><h2 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h2><h3 id="线程函数-1"><a href="#线程函数-1" class="headerlink" title="线程函数"></a>线程函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ptread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这是一个阻塞函数，运行到这个函数时，线程会被阻塞</span></span><br><span class="line"><span class="comment">// 子线程退出，函数解除阻塞，回收对应的子线程资源</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数：<ul><li>thread：要被回收的子线程的线程ID</li><li>retval：二级指针，是一个传出参数，这个地址中存储了pthread_exit()传递出的数据，如果不需要，可以指定为NULL。</li></ul></li><li>返回值：线程回收成功返回0，回收失败返回错误号。</li></ul><h3 id="回收子线程数据"><a href="#回收子线程数据" class="headerlink" title="回收子线程数据"></a>回收子线程数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程: i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程：%ld\n&quot;</span>, pthread_self());</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line">t.num = <span class="number">100</span>;</span><br><span class="line">t.age = <span class="number">6</span>;</span><br><span class="line">pthread_exit(&amp;t);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;主线程: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"><span class="type">void</span>* ptr;</span><br><span class="line">pthread_join(tid, &amp;ptr);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">pt</span> =</span> (<span class="keyword">struct</span> Test*)ptr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num : %d, age : %d\n&quot;</span>, pt-&gt;num,pt-&gt;age);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240314210611771.png" alt="image-20240314210611771"></p><p>因为t在栈区，所以当子进程结束后， ptr指向的地址空间会被释放，因此最后的输出会是随机数。</p><p>将struct Test t定义成全局变量后，num和age正常输出。</p><p><img src="/pic/image-20240314211832344.png" alt="image-20240314211832344"></p><p>或者将t定义在main函数中，并传入到callback内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">callback</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程: i = %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;子线程：%ld\n&quot;</span>, pthread_self());</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>* <span class="title">t</span> =</span> (<span class="keyword">struct</span> Test*)arg;</span><br><span class="line">t-&gt;num = <span class="number">100</span>;</span><br><span class="line">t-&gt;age = <span class="number">6</span>;</span><br><span class="line">pthread_exit(t);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> <span class="title">t</span>;</span></span><br><span class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, &amp;t);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;主线程: %ld\n&quot;</span>, pthread_self());</span><br><span class="line"><span class="type">void</span>* ptr;</span><br><span class="line">pthread_join(tid, &amp;ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;num : %d, age : %d\n&quot;</span>, t.num,t.age);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240314212709827.png" alt="image-20240314212709827"></p><h2 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h2><p>子线程和主线程分离，当子线程退出时，其占用的内核资源就系统的其他进程接管并回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数：子线程的线程ID。主线程就和这个子线程分离了</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><p>在某些特定情况下在一个线程中杀死另一个线程，总共有两步：</p><p>1.调用pthread_cancel，被指定的线程B不会马上死亡。</p><p>2.线程B中进行一次系统调用后，线程B死亡；否则线程B可以一直运行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门（一）</title>
      <link href="/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%80/"/>
      <url>/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础入门（一）"><a href="#Linux基础入门（一）" class="headerlink" title="Linux基础入门（一）"></a>Linux基础入门（一）</h1><h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><p>Linux系统分为内核空间和用户空间。内核空间是Linux操作系统的主要部分，但是仅有内核的操作系统是不能完成用户任务的。丰富并且功能强大的应用程序包是一个操作系统成功的必要件。</p><p>Linux的内核主要由5个子系统组成：进程调度，内存管理，虚拟文件系统，网络接口，进程间通信。</p><p>进程调度 SCHED</p><ul><li>SCHED_OTHER：分时调度策略（默认），是用于针对普通进程的时间片轮转调度策略。</li><li>SCHED_FIFO：实时调度策略，是针对运行的实时性要求比较高，运行时间短的进程调度策略。</li><li>SCHED_RR：实时调度策略，是针对实时性要求比较高，运行时间比较长的进程调度策略。</li></ul><p>内存管理 MMU</p><ul><li>内存管理是多个进程间的内存共享策略。在Linux中，内存管理主要说的是虚拟内存。</li><li>虚拟内存可以让进程拥有比实际物理内存更大的内存，可以是实际内存的很多倍。</li><li>每个进程的虚拟内存有不同的地址空间，多个进程的虚拟内存不会冲突。</li></ul><p>虚拟文件系统 VFS</p><ul><li>在Linux下支持多种文件系统，如ext，ext2，minix，umsdos，msdos，vfat，ntfs等。</li><li>目前Linux下最常用的文件格式是ext2和ext3。</li></ul><p>网络接口</p><ul><li>Linux支持多种网络接口和协议。网络接口分为网络协议和驱动程序，网络协议是一种网络传输的通信标准，而网络驱动则是对硬件设备的驱动程序。Linux支持的网络设备多种多样，几乎目前所有网络设备都有驱动程序。</li></ul><p>进程间通信</p><ul><li>Linux操作系统支持多进程，进程之间需要进行数据的交流才能完成控制，协同工作等功能，Linux的进程间通信是从UNIX系统继承过来的。Linux下的进程间的通信方式主要有管道、信号量、消息队列、共享内存和套接字等方法。</li></ul><h2 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h2><h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p><img src="/pic/image-20240229161709694.png" alt="image-20240229161709694"></p><p>在Linux中根目录的子目录结构相对是固定的（名字固定），不同的目录功能也是固定的</p><ul><li><p>bin: binary, 二进制文件目录, 存储了可执行程序, 今天要将的命令对应的可执行程序都在这个目录中</p></li><li><p>sbin: super binary, root用户使用的一些二进制可执行程序</p></li><li><p>etc: 配置文件目录, 系统的或者用户自己安装的应用程序的配置文件都存储在这个目录中</p></li><li><p>lib: library, 存储了一些动态库和静态库，给系统或者安装的软件使用</p></li><li><p>media: 挂载目录, 挂载外部设备，比如: 光驱, 扫描仪</p></li><li><p>mnt: 临时挂载目录, 比如我们可以将U盘临时挂载到这个目录下</p></li><li><p>proc: 内存使用的一个映射目录, 给操作系统使用的</p></li><li><p>tmp: 临时目录, 存放临时数据, 重启电脑数据就被自动删除了</p></li><li><p>boot: 存储了开机相关的设置</p></li><li><p>home: 存储了普通用户的家目录，家目录名和用户名相同</p></li><li><p>root: root用户的家目录</p></li><li><p>dev: device , 设备目录, Linux中一切皆文件, 所有的硬件会抽象成文件存储起来，比如：键盘， 鼠标</p></li><li><p>lost+found: 一般时候是空的, 电脑异常关闭&#x2F;崩溃时用来存储这些无家可归的文件, 用于用户系统恢复</p></li><li><p>opt: 第三方软件的安装目录</p></li><li><p>var: 存储了系统使用的一些经常会发生变化的文件， 比如：日志文件</p></li><li><p>usr: unix system resource, 系统的资源目录</p></li><li><ul><li><p>&#x2F;usr&#x2F;bin: 可执行的二进制应用程序</p></li><li><p>&#x2F;usr&#x2F;games: 游戏目录</p></li><li><p>&#x2F;usr&#x2F;include: 包含的标准头文件目录</p></li><li><p>&#x2F;usr&#x2F;local: 和opt目录作用相同, 安装第三方软件</p></li></ul></li></ul><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>相对路径：相对路径就是相对于当前文件的路径。在Linux中有两个表示路径的特殊符号:</p><ul><li><p>.&#x2F;：代表目前所在的目录，也可以使用 .表示。</p></li><li><p>..&#x2F;：代表当前目录的上一层目录，也可以使用 ..表示。</p></li></ul><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>绝对路径：从系统磁盘起始节点开始描述的路径。</p><ul><li><p>Linux：起始节点为根目录，比如： &#x2F;root&#x2F;os。</p></li><li><p>Windows: 起始节点为某个磁盘的盘符。</p></li></ul><h2 id="命令解析器"><a href="#命令解析器" class="headerlink" title="命令解析器"></a>命令解析器</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Linux终端是如何识别并且运行那些用户输入的命令的呢？这些命令都是通过命令解析器解析完成并执行的。</p><p>命令解析器是在Linux操作系统中就是一个进程，叫做bash。其工作的具体步骤如下：</p><p>在Linux中有一个叫叫做PATH的环境变量，里面存储了一些系统目录。我们可以通过echo $PATH命令查看。</p><p><img src="/pic/image-20240229162538698.png" alt="image-20240229162538698"></p><p>命令解析器需要依次搜索PATH中的各个目录，检查这些目录是否有用户输入的指令。</p><ul><li>如果找到了，执行该目录下的可执行程序，用户输入的命令就被执行完毕了。</li><li>如果没有找到，继续搜索其他目录，最后还是没有找到，会提示命令找不到。</li></ul><h3 id="命令提示行"><a href="#命令提示行" class="headerlink" title="命令提示行"></a>命令提示行</h3><p><img src="/pic/image-20240229162904645.png" alt="image-20240229162904645"></p><ul><li>krito:当前登录的用户的用户名</li><li>@:在</li><li>localhost：主机名，在安装Linux操作系统时手动指定，可以修改、</li><li>~：当前用户的家目录</li><li>#：代表当前用户是root用户</li><li>$：代表当前用户是普通用户。</li></ul><h3 id="命令行快捷键"><a href="#命令行快捷键" class="headerlink" title="命令行快捷键"></a>命令行快捷键</h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>功能</strong></th><th align="left"><strong>备注</strong></th></tr></thead><tbody><tr><td align="left">Tab</td><td align="left">命令自动补齐</td><td align="left">在终端中输入某个命令的前一个或若干个字符，再按Tab键</td></tr><tr><td align="left">Ctrl+p</td><td align="left">显示输入的上一个历史命令</td><td align="left">从输入的最后一个命令往前倒，也可以使用↑键</td></tr><tr><td align="left">Ctrl+n</td><td align="left">显示输入的下一个历史命令</td><td align="left">也可以使用↓键</td></tr><tr><td align="left">Ctrl+a</td><td align="left">光标移动命命令行首</td><td align="left">也可以使用Home键</td></tr><tr><td align="left">Ctrl+e</td><td align="left">光标移动命命令行尾</td><td align="left">也可以使用End键</td></tr><tr><td align="left">Ctrl+u</td><td align="left">删除光标前的部分字符串</td><td align="left">无</td></tr><tr><td align="left">Ctrl+k</td><td align="left">删除光标后的部分字符串</td><td align="left">无</td></tr><tr><td align="left">→</td><td align="left">光标向右移动一个字符</td><td align="left">无</td></tr><tr><td align="left">←</td><td align="left">光标向左移动一个字符</td><td align="left">无</td></tr><tr><td align="left">Backspace&#x2F;Delete</td><td align="left">删除光标前&#x2F;后的一个字符</td><td align="left">无</td></tr></tbody></table><h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><p>进入指定目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目录名</span><br></pre></td></tr></table></figure><ul><li>目录名：使用相对路径&#x2F;绝对路径都可以</li><li>特色目录：..表示当前目录的上一级目录，使用cd .. 或者cd ..&#x2F;都可以；.表示当前目录，cd . 不会切换目录。</li></ul><p>进入家目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span>                    <span class="comment"># 方式1</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~                  <span class="comment"># 方式2</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/用户名        <span class="comment"># 方式3</span></span></span><br></pre></td></tr></table></figure><p>在临近的两个目录之间切换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> -</span></span><br></pre></td></tr></table></figure><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><h4 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a>用户类型</h4><p>在Linux中有三大类用户：文件所有者，文件所属组用户，其他人，我们可以对同一个文件给这三种人设置不同的操作权限。</p><ul><li>文件所有者：Linux中的所有的文件都有一个所有者，就是文件的主人。</li><li>文件所属组：</li></ul><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>权限一共有四种：读权限，写权限，执行权限，无权限。</p><ul><li>读权限：使用r表示，即：read。</li><li>写权限：使用w表示，即：write。</li><li>执行权限：使用x表示，即：excute。</li><li>没有任何权限：使用-表示。</li></ul><p><img src="/pic/image-20240301185538543.png" alt="image-20240301185538543"></p><p>第一个字符为文件类型，接下来每三个字符分别代表的是文件所有者，文件所属组用户，其他人对文件的操作权限。这个例子里，所有用户都对文件有读、写、执行权限。</p><h4 id="硬链接计数"><a href="#硬链接计数" class="headerlink" title="硬链接计数"></a>硬链接计数</h4><p>每当我们给磁盘文件创建一个硬链接（使用ln），磁盘上就会出现一个新的文件名，硬链接技术加1，但是这新文件并不占用任何的磁盘空间，文件名还是映射到原来的磁盘地址上。</p><ul><li>和直接进行文件拷贝的区别是，创建硬链接只是多了一个新的文件名，拷贝文件不仅多了新的文件名，在磁盘上数据也进行了拷贝。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> 文件A 文件B</span><br></pre></td></tr></table></figure><h3 id="创建删除目录"><a href="#创建删除目录" class="headerlink" title="创建删除目录"></a>创建删除目录</h3><p>创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单层目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 新目录名字</span><br><span class="line"></span><br><span class="line"><span class="comment">#多层目录，需要加参数 -p</span></span><br><span class="line"> <span class="built_in">mkdir</span> root/a/b/c -p</span><br></pre></td></tr></table></figure><p>删除目录</p><p>如果要删除已经存在的路径，可以使用rmdir或者rm</p><ul><li>rmdir：只能删除空目录</li><li>rm：可以删除文件也可以删除目录，如果要删除目录，需要加参数-r。(recursion)</li></ul><p>rm命令常用参数:</p><ul><li>-i：删除的时候给提示</li><li>-f：强制删除文件，没有提示直接删除并且不能恢复。</li></ul><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p> 拷贝文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 要拷贝的文件 得到的文件</span><br></pre></td></tr></table></figure><p>拷贝目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 文件A 文件B -r</span><br></pre></td></tr></table></figure><h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p>文件的移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mv 要移动的文件 目录</span></span><br><span class="line"><span class="comment">#把文件A移动到目录B中</span></span><br><span class="line"><span class="built_in">mv</span> A B</span><br></pre></td></tr></table></figure><p>文件改名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mv 要改名的文件 新名字（必须是原来不存在的）</span></span><br><span class="line"><span class="comment"># 其中A可以是文件也可以是目录，并且是存在的，B原来是不存在的</span></span><br><span class="line"><span class="built_in">mv</span> A B</span><br></pre></td></tr></table></figure><p>文件覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mv 存在的文件A 存在的文件B</span></span><br><span class="line"><span class="comment"># A文件中的内容覆盖B文件中的内容，A文件被删除，只剩下B文件。</span></span><br><span class="line"><span class="built_in">mv</span> A B</span><br></pre></td></tr></table></figure><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat，将文件内容显示到终端，如果文件太大则无法完全显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件名</span><br></pre></td></tr></table></figure><p>more，可以翻屏查看文件中的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">more 文件名</span><br><span class="line">快捷键</span><br><span class="line">- 回车：显示下一行</span><br><span class="line">- 空格：向下滚动一屏</span><br><span class="line">- b：返回上一屏</span><br><span class="line">- q：退出</span><br></pre></td></tr></table></figure><p>less，和more相似。</p><p>head，查看文件头部的若干行信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认显示文件的前10行</span></span><br><span class="line"><span class="built_in">head</span> -行数 文件名</span><br></pre></td></tr></table></figure><p>tail，查看文件尾部的若干行信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -行数 文件名</span><br></pre></td></tr></table></figure><h3 id="连接的创建"><a href="#连接的创建" class="headerlink" title="连接的创建"></a>连接的创建</h3><p>连接分两种类型：软链接和硬链接。软链接相当于windows中的快捷方式，硬链接文件并不会进行拷贝，只是多出一个新的文件名并且硬链接计数会加1。</p><h4 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 源文件路径（建议使用绝对路径） 软连接文件名</span><br></pre></td></tr></table></figure><p>a.lnk为相对路径</p><p><img src="/pic/image-20240301210140554.png" alt="image-20240301210140554"></p><p>我们将其移动后，a.lnk变成红色，变为不可用。</p><p><img src="/pic/image-20240301210227851.png" alt="image-20240301210227851"></p><p>a.lnk指向当前目录下的a.txt，所有推荐使用绝对路径。</p><p><img src="/pic/image-20240301210344584.png" alt="image-20240301210344584"></p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln 源文件 硬链接文件名</span><br></pre></td></tr></table></figure><p>硬链接与软链接不同，它是通过文件名直接找对应的硬盘地址，而不是基于路径，所以源文件直接使用相对路径即可，无需指定绝对路径。目录不允许创建硬链接。</p><h3 id="文件权限-1"><a href="#文件权限-1" class="headerlink" title="文件权限"></a>文件权限</h3><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#chmod</span></span><br><span class="line"><span class="comment">#语法格式: chmod who[+|-|=]mod 文件名</span></span><br><span class="line">- <span class="built_in">who</span>:</span><br><span class="line">- u: user  -&gt; 文件所有者</span><br><span class="line">- g: group -&gt; 文件所属组用户</span><br><span class="line">- o: other -&gt; 其他</span><br><span class="line">- a: all, 以上是三类人 u+g+o</span><br><span class="line">- 对权限的操作:</span><br><span class="line">+: 添加权限</span><br><span class="line">-: 去除权限</span><br><span class="line">=: 权限的覆盖</span><br><span class="line">- mod: 权限</span><br><span class="line">r: <span class="built_in">read</span>, 读</span><br><span class="line">w: write, 写</span><br><span class="line">x: execute, 执行</span><br><span class="line">-: 没有权限</span><br></pre></td></tr></table></figure><p>给所有人读、写、执行权限</p><p><img src="/pic/image-20240301211913336.png" alt="image-20240301211913336"></p><p>去除文件所有者的执行权限</p><p><img src="/pic/image-20240301212023920.png" alt="image-20240301212023920"></p><h4 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只修改所有者</span></span><br><span class="line">sudo <span class="built_in">chown</span> 新的所有者 文件名</span><br><span class="line"><span class="comment">#同时修改所有者和所属组</span></span><br><span class="line">sudo <span class="built_in">chown</span> 新的所有者:新的组名 文件名</span><br></pre></td></tr></table></figure><p>修改文件所有者为root。</p><p><img src="/pic/image-20240301213427378.png" alt="image-20240301213427378"></p><h4 id="修改文件所属组"><a href="#修改文件所属组" class="headerlink" title="修改文件所属组"></a>修改文件所属组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chgrp</span> 新的组名 文件名</span><br></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p>显示当前用户所在的工作目录</p><p><img src="/pic/image-20240301213934756.png" alt="image-20240301213934756"></p><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p>创建一个新的空文件，如果指定文件已存在，只会更新该文件的修改日期，对内容没有任何影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> 文件名</span><br></pre></td></tr></table></figure><h4 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h4><p>查看要执行的命令所在的实际路径。</p><p><img src="/pic/image-20240301214624620.png" alt="image-20240301214624620"></p><h4 id="重定向命令"><a href="#重定向命令" class="headerlink" title="重定向命令"></a>重定向命令</h4><p>输出重定向：修改输出的数据的位置。将原来显示在终端的数据输入到文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;:将输出的内容写入到指定文件中，如果文件中已有数据，则会使用新数据覆盖。</span><br><span class="line">&gt;&gt;:将输出的内容追加到指定文件尾部。</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240301221224690.png" alt="image-20240301221224690"></p><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只切换用户，工作目录不变</span></span><br><span class="line">su 用户名</span><br><span class="line"><span class="comment"># 切换用户和工作目录，会自动跳转到当前用户的家目录中</span></span><br><span class="line">su - 用户名</span><br><span class="line"><span class="comment"># 回到原来的用户</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h3 id="添加删除用户"><a href="#添加删除用户" class="headerlink" title="添加删除用户"></a>添加删除用户</h3><h4 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line">sudo adduser 用户名</span><br><span class="line"><span class="comment"># centos</span></span><br><span class="line">sudo useradd 用户名</span><br><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">sudo useradd -m -s /bin/bash 用户名</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240302135738891-1709359060351-1.png" alt="image-20240302135738891"></p><p>centos创建用户后，需要更改用户密码。</p><p><img src="/pic/image-20240302135811122.png" alt="image-20240302135811122"></p><p>修改完密码后，使用新密码登入新用户。</p><p><img src="/pic/image-20240302135844711.png" alt="image-20240302135844711"></p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除用户，添加参数 -r 就可以一并删除用户的家目录</span></span><br><span class="line">sudo userdel 用户名 -r</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240302140407309.png" alt="image-20240302140407309"></p><h3 id="添加和删除用户组"><a href="#添加和删除用户组" class="headerlink" title="添加和删除用户组"></a>添加和删除用户组</h3><p>默认情况下，只要创建新用户就会得到一个同名的用户组，并且这个用户属于这个组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd 组名</span><br><span class="line">sudo groupdel 组名</span><br></pre></td></tr></table></figure><p>在&#x2F;etc&#x2F;group文件中，查看所有的用户组。</p><p><img src="/pic/image-20240302141003188.png" alt="image-20240302141003188"></p><p><img src="/pic/image-20240302140948482.png" alt="image-20240302140948482"></p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改当前用户密码</span></span><br><span class="line">passwd</span><br><span class="line"><span class="comment"># 修改非当前用户密码</span></span><br><span class="line">sudo passwd 用户名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门（四）</title>
      <link href="/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%9B%9B/"/>
      <url>/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>Makefile的框架由规则构成。make命令执行时先在Makefile文件中查找各种规则，对各种规则进行解析后运行规则。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每条规则的语法格式：</span></span><br><span class="line"><span class="section">target1,target2...: depend1, depend2, ...</span></span><br><span class="line">command</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>每条规则由三个部分组成，分别是目标(target)，依赖(depend)和命令(command)。</p><ul><li>命令(command)：当前这条规则的动作，一般情况下是一个shell命令。<ul><li>例如：通过某个命令编译文件，生成库文件，进入目录等。</li><li>动作可以是多个，每个命令前必须有一个tab并且独占一行</li></ul></li><li>依赖(depend)：规则所必需的依赖条件，在规则的命令中可以使用这些依赖。<ul><li>可以为空，可以是其他规则中的某个目标，可以指定多个。</li></ul></li><li>目标(target)：规则中的目标，这个目标和规则中的命令是对应的<ul><li>通过执行命令，可以生成一个和目标同名的文件。</li><li>规则中可以有多个命令，因此可以有多个目标。</li></ul></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单个目标，单个命令</span></span><br><span class="line"><span class="section">app:a.c b.c c.c</span></span><br><span class="line">gcc a.c b.c c.c -o app</span><br><span class="line"></span><br><span class="line"><span class="comment">#多个目标，多个命令</span></span><br><span class="line"><span class="section">app,app1:a.c b.c c.c d.c</span></span><br><span class="line">gcc a.c b.c -o app</span><br><span class="line">gcc c.c d.c -o app1</span><br><span class="line"></span><br><span class="line"><span class="comment">#规则之间的嵌套</span></span><br><span class="line"><span class="section">app:a.o b.o c.o</span></span><br><span class="line">gcc a.o b.o c.o -o app</span><br><span class="line"><span class="section">a.o:a.c</span></span><br><span class="line">gcc -c a.c</span><br><span class="line"><span class="section">b.o:b.c</span></span><br><span class="line">gcc -c b.c</span><br><span class="line"><span class="section">c.o:c.c</span></span><br><span class="line">gcc -c c.c</span><br></pre></td></tr></table></figure><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="文件时间戳"><a href="#文件时间戳" class="headerlink" title="文件时间戳"></a>文件时间戳</h3><p>make命令执行时会根据文件的时间戳判定是否执行makefile文件中相关规则的命令。</p><ul><li>目标是通过依赖生成，所以正常情况下：目标时间戳&gt;所有依赖的时间戳，如果执行make命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不被执行。</li><li>当依赖文件被更新时，目标时间戳&lt;某些依赖的时间戳，在这种情况下目标文件会被重新生成。</li><li>如果目标文件不存在，规则中的命令看到会被执行。</li></ul><h3 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h3><p>make有自动推导的能力，不会完全依赖makefile。</p><p>makefile内容：</p><p><img src="/pic/image-20240309205941666.png" alt="image-20240309205941666"></p><p><img src="/pic/image-20240309210136746.png" alt="image-20240309210136746"></p><p><img src="/pic/image-20240309210002712.png" alt="image-20240309210002712"></p><p>前五条命令为make自动推导的结果。</p><h1 id="GBD"><a href="#GBD" class="headerlink" title="GBD"></a>GBD</h1><h2 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h2><p>生成可用于调试的可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -g -Wall -O0 -o app</span><br></pre></td></tr></table></figure><p> 使用gdb 进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb app</span><br></pre></td></tr></table></figure><p>设置命令行参数</p><p><img src="/pic/image-20240310124549878.png" alt="image-20240310124549878"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行到第一个断点，如果没有设置断点，程序直接执行完</span></span><br><span class="line">run</span><br><span class="line"><span class="comment"># 启动程序，最终会阻塞在main函数第一行</span></span><br><span class="line">start</span><br><span class="line"><span class="comment"># 退出gdb</span></span><br><span class="line">quit/q</span><br></pre></td></tr></table></figure><p>run命令，没有断点则直接执行完程序。</p><p><img src="/pic/image-20240310124737571.png" alt="image-20240310124737571"></p><h2 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h2><p>当前文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从第一行开始显示</span></span><br><span class="line">(gdb) list </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列值这行号对应的上下文代码, 默认情况下只显示10行内容</span></span><br><span class="line">(gdb) list 行号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示这个函数的上下文内容, 默认显示10行</span></span><br><span class="line">(gdb) list 函数名</span><br></pre></td></tr></table></figure><p>切换文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l 文件名:行号</span><br><span class="line"></span><br><span class="line">l 文件名:函数名</span><br></pre></td></tr></table></figure><p>设置显示的行数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两个命令中的 listsize 都可以写成 list</span></span><br><span class="line"><span class="built_in">set</span> listsize 行数</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前list一次显示的行数</span></span><br><span class="line">show listsize</span><br></pre></td></tr></table></figure><h2 id="断点操作"><a href="#断点操作" class="headerlink" title="断点操作"></a>断点操作</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>断点的设置有两种方式，一种是常规断点，程序只要运行到这个位置就会被阻塞；还有一种叫条件断点，只有指定的条件被满足了程序才会在断点处阻塞。</p><p>设置普通断点到当前文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前文件的某一行上设置断点</span></span><br><span class="line"><span class="comment"># break = b</span></span><br><span class="line">b 行号</span><br><span class="line">b 函数名</span><br></pre></td></tr></table></figure><p>设置普通断点到某个非当前文件上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在非当前文件的某一行上设置断点</span></span><br><span class="line">b 文件名:行号</span><br><span class="line">b 文件名:函数名</span><br></pre></td></tr></table></figure><p>设置条件断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b  行数 <span class="keyword">if</span> 变量名==某个值</span><br></pre></td></tr></table></figure><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info breakpoint</span><br><span class="line">i b</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310141015418.png" alt="image-20240310141015418"></p><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete == del == d</span></span><br><span class="line">d 断点的编号1 [断点编号2 ...]</span><br><span class="line">d 1</span><br><span class="line">d 2 4 6</span><br><span class="line">d 1-5</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310141215534.png" alt="image-20240310141215534"></p><h3 id="设置断点状态"><a href="#设置断点状态" class="headerlink" title="设置断点状态"></a>设置断点状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#设置断点无效</span><br><span class="line"># disable == dis</span><br><span class="line">#设置某一个或者某几个断点无效</span><br><span class="line">dis 断点1的编号</span><br><span class="line">dis 1-5</span><br><span class="line">#生效enable = ena</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310141418525.png" alt="image-20240310141418525"></p><p>编号6的断点Ebh变为n</p><p><img src="/pic/image-20240310141454631.png" alt="image-20240310141454631"></p><h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><p>继续运行gdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># continue = c</span></span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p> 打印变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># print = p</span><br><span class="line">p 变量名</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310144055829.png" alt="image-20240310144055829"></p><p>打印变量类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptype 变量名</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310144313726.png" alt="image-20240310144313726"></p><p>自动打印信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display 变量名</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310144547924.png" alt="image-20240310144547924"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除自动显示</span></span><br><span class="line">delete display num</span><br><span class="line"><span class="comment">#停用</span></span><br><span class="line"><span class="built_in">disable</span> display num</span><br><span class="line"><span class="comment">#启用</span></span><br><span class="line"><span class="built_in">enable</span> display num</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310144716007.png" alt="image-20240310144716007"></p><h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><p>执行下一行，如果是函数调用，则会进入到函数体内部。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step == s</span></span><br><span class="line">step</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310154958050.png" alt="image-20240310154958050"></p><p>跳出函数体</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finish</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310155040279.png" alt="image-20240310155040279"></p><p>执行下一行，不会进入函数体内部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#next == n</span></span><br><span class="line">next</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310155100436.png" alt="image-20240310155100436"></p><p>跳出循环体。循环体内无有效断点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span></span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310155922854.png" alt="image-20240310155922854"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门（三）</title>
      <link href="/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%89/"/>
      <url>/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础入门（三）"><a href="#Linux基础入门（三）" class="headerlink" title="Linux基础入门（三）"></a>Linux基础入门（三）</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC是Linux下的编译工具集，是GNU Compiler Collection的缩写，包含gcc、g++等编译器，这个工具集不仅包含编译器，还包含其他工具集，例如ar、nm等。</p><h3 id="安装GCC"><a href="#安装GCC" class="headerlink" title="安装GCC"></a>安装GCC</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ubuntu</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc g++</span><br><span class="line"></span><br><span class="line">centos</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install gcc g ++</span><br><span class="line"></span><br><span class="line">查看gcc版本</span><br><span class="line">gcc -v</span><br><span class="line"></span><br><span class="line">查看g++版本</span><br><span class="line">g++ -v</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240307124527126.png" alt="image-20240307124527126"></p><h3 id="gcc工作流程"><a href="#gcc工作流程" class="headerlink" title="gcc工作流程"></a>gcc工作流程</h3><p>GCC编译器对程序的编译分为四个阶段：预处理（预编译）、编译和优化、汇编和链接。GCC编译器可以将这四个步骤合并成一个。</p><p>1.预处理：GCC调用预处理器来完成；展开头文件、宏替换、去掉注释行。</p><p>2.编译：GCC调用编译器对文件进行编译，最终得到一个汇编文件。</p><p>3.汇编：GCC调用汇编器对文件进行汇编，最终得到一个二进制文件。</p><p>4.链接：GCC调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件。</p><table><thead><tr><th>文件名后缀</th><th>说明</th><th>gcc参数</th></tr></thead><tbody><tr><td>.c</td><td>源文件</td><td>无</td></tr><tr><td>.i</td><td>预处理后的C文件</td><td>-E</td></tr><tr><td>.s</td><td>编译之后得到的汇编语言的源文件</td><td>-S</td></tr><tr><td>.o</td><td>汇编后得到的二进制文件</td><td>-c</td></tr></tbody></table><p><img src="/pic/image-20240307125904722.png" alt="image-20240307125904722"></p><p>test.c</p><p><img src="/pic/image-20240307130209517.png" alt="image-20240307130209517"></p><p>test.i</p><p><img src="/pic/image-20240307130150335.png" alt="image-20240307130150335"></p><p>test.s</p><p><img src="/pic/image-20240307130412927.png" alt="image-20240307130412927"></p><p>test.o</p><p><img src="/pic/image-20240307130516326.png" alt="image-20240307130516326"></p><p>最后运行</p><p><img src="/pic/image-20240307130552101.png" alt="image-20240307130552101"></p><p>我们也可以直接gcc test.c -o test。</p><h3 id="gcc常用参数"><a href="#gcc常用参数" class="headerlink" title="gcc常用参数"></a>gcc常用参数</h3><h4 id="指定生成的文件名-o"><a href="#指定生成的文件名-o" class="headerlink" title="指定生成的文件名(-o)"></a>指定生成的文件名(-o)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o 生成文件名</span><br></pre></td></tr></table></figure><h4 id="搜索头文件-l"><a href="#搜索头文件-l" class="headerlink" title="搜索头文件(-l)"></a>搜索头文件(-l)</h4><p>指定要引用的头文件路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -I include</span><br></pre></td></tr></table></figure><h4 id="指定一个宏-D"><a href="#指定一个宏-D" class="headerlink" title="指定一个宏(-D)"></a>指定一个宏(-D)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 源文件 -D 宏定义</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240307161527012.png" alt="image-20240307161527012"></p><p>gcc test.c</p><p><img src="/pic/image-20240307161611531.png" alt="image-20240307161611531"></p><p><img src="/pic/image-20240307161715163.png" alt="image-20240307161715163"></p><h3 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h3><p>gcc无法自动链接到c++标准库，需要指定参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.cpp -l stdc++</span><br></pre></td></tr></table></figure><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>在Linux中静态库由程序ar生成。</p><ul><li>在Linux中静态库以lib作为前缀，以.a作为后缀，中间是库的名字，即：libxxx.a</li><li>在Windows中静态库一般以lib作为前缀，以lib作为后缀，中间是库的名字，即：libxxx.lib</li></ul><h4 id="生成静态库"><a href="#生成静态库" class="headerlink" title="生成静态库"></a>生成静态库</h4><p>生成静态库，需要先对源文件进行汇编操作得到二进制格式的目标文件，然后再通过ar工具将目标文件打包就可以得到静态库文件了。</p><ul><li>参数c：创建一个库。</li><li>参数s：创建目标文件索引，在创建较大的库时能加快时间。</li><li>参数r：在库中插入模块（替换）。</li></ul><p>生成静态链接库的具体步骤如下：</p><p>1.需要将源文件进行汇编，得到.o文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行如下操作，默认生成二进制的.o文件</span></span><br><span class="line">gcc 源文件(*.c) -c </span><br></pre></td></tr></table></figure><p> 2.将得到的.o进行打包，得到静态库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs 静态库的名字 原材料(*.o)</span><br></pre></td></tr></table></figure><p>sub.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>head.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, add(a, b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a - b = %d\n&quot;</span>, subtract(a, b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a * b = %d\n&quot;</span>, multiply(a, b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a / b = %f\n&quot;</span>, divide(a, b));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240309150724507.png" alt="image-20240309150724507"></p><p><img src="/pic/image-20240309151809802.png" alt="image-20240309151809802"></p><p><img src="/pic/image-20240309151904844.png" alt="image-20240309151904844"></p><p><img src="/pic/image-20240309152344807.png" alt="image-20240309152344807"></p><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在Linux中动态链接库也可以称之为共享库。</p><ul><li>在Linux中动态库以lib作为前缀，以.so作为后缀，中间是库的名字，例如：libxxx.so</li><li>在Windows中动态库一般以lib作为前缀，以dll作为后缀，中间是库的名字，例如：libxxx.dll</li></ul><p> </p><h4 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h4><p>直接使用gcc命令并且需要添加-fPIC（-fpic）以及-shared参数。</p><ul><li>-fPIC或-fpic参数的作用是使得gcc生成的代码是与位置无关的，也就是使用相对位置。</li><li>-shared参数是告诉编译器生成一个动态链接库</li></ul><p>生成动态链接库的具体步骤如下：</p><p>1.将源文件进行汇编操作、需要使用参数-c，还需要添加额外此参数 -fpic&#x2F;-fPIC</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">得到若干个 .o文件</span><br><span class="line">gcc 源文件(*.c) -c -fpic</span><br></pre></td></tr></table></figure><p>2.将得到的.o文件打包成动态库，还是使用gcc，使用参数 -shared 指定生成动态库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so)</span><br></pre></td></tr></table></figure><p>3.发布动态库和头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.提供头文件：xxx.h</span><br><span class="line">2.提供动态库：libxxx.so</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240309152830627.png" alt="image-20240309152830627"></p><p><img src="/pic/image-20240309152810286.png" alt="image-20240309152810286"></p><p><img src="/pic/image-20240309153126857.png" alt="image-20240309153126857"></p><p><img src="/pic/image-20240309153111078.png" alt="image-20240309153111078"></p><h4 id="解决动态库无法加载问题"><a href="#解决动态库无法加载问题" class="headerlink" title="解决动态库无法加载问题"></a>解决动态库无法加载问题</h4><h5 id="库的工作原理"><a href="#库的工作原理" class="headerlink" title="库的工作原理"></a>库的工作原理</h5><ul><li><p>静态库加载</p><p>静态库会被打包到可执行程序中，当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。</p></li><li><p>动态库加载</p><p>gcc命令中虽然指定了库路径（-L），但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。</p><p>动态库文件没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。</p></li></ul><p>可执行程序被执行后，会先检测需要的动态库是否可以被加载，加载不到就会提示错误信息。</p><p>当动态库中的函数在程序中被调用了，这时候动态库才加载到内存，如果不被调用就不加载。</p><p>动态库的检测和内存加载操作都是由动态连接器来完成的。</p><h5 id="动态链接器"><a href="#动态链接器" class="headerlink" title="动态链接器"></a>动态链接器</h5><p>动态链接器是一个独立的进程，当用户的程序需要加载动态库时，动态链接器开始工作。</p><p>动态链接器的搜索顺序：</p><p>1.可执行文件内部的DT_RPATH段</p><p>2.系统的环境变量LD_LIBRARY_PATH</p><p>3.系统动态库的缓存文件&#x2F;etc&#x2F;ld.so.cache</p><p>4.存储动态库 &#x2F; 静态库的系统目录 &#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib等</p><p>如果按照上面四个顺序搜索，最后还是没找到，动态链接器就会提示错误信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd 可执行文件 <span class="comment">#检查可执行文件所需的动态库能否被正确加载</span></span><br></pre></td></tr></table></figure><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>方案1：将库路径添加到环境变量LD_LIBRARY_PATH中</p><p>1.找到配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/.bashrc 对当前用户有效</span><br><span class="line">/etc/profile 对所有用户有效</span><br></pre></td></tr></table></figure><p>2.使用vim打开配置文件，在文件最后添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:动态库的绝对路径</span><br></pre></td></tr></table></figure><p>3.配置文件生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc          (. ~/.bashrc)</span><br><span class="line"><span class="built_in">source</span> /etc/profile       (. /etc/profile)</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240309154359422.png" alt="image-20240309154359422"></p><p><img src="/pic/image-20240309154412551.png" alt="image-20240309154412551"></p><p>方案2: 更新 &#x2F;etc&#x2F;ld.so.cache 文件</p><ol><li><p>找到动态库所在的绝对路径 比如：<code>/home/krito/Library/</code></p></li><li><p>修改 <code>/etc/ld.so.conf</code>，将路径添加到该文件末尾。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br></pre></td></tr></table></figure></li><li><p>更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ol><p>方案3: 拷贝动态库文件到系统库目录 <code>/lib/</code> 或者 <code>/usr/lib</code> 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 库拷贝</span></span><br><span class="line">sudo <span class="built_in">cp</span> /xxx/xxx/libxxx.so /usr/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建软连接</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240309154814930.png" alt="image-20240309154814930"></p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>静态库优点：</p><ul><li>静态库被打包到应用程序中，加载速度更快</li><li>发布程序无需提供静态库，移植方便</li></ul><p>静态库缺点：</p><ul><li>相同的库文件可能会在内存中加载多份，消耗系统资源，浪费内存。</li><li>库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间。</li></ul><p>动态库优点：</p><ul><li>可实现不同进程间的资源共享</li><li>动态库升级简单，只需要替换库文件，无需重新编译应用程序</li><li>可控制何时加载</li></ul><p>动态库缺点：</p><ul><li>加载速度比静态库慢</li><li>发布程序需要提供依赖的动态库</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门（二）</title>
      <link href="/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
      <url>/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础入门（二）"><a href="#Linux基础入门（二）" class="headerlink" title="Linux基础入门（二）"></a>Linux基础入门（二）</h1><h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>​tar是打包工具，不能压缩文件。gzip和bzip2，不能打包压缩文件，每个文件都会生成一个单独的压缩包，并且压缩之后不会保留原文件。</p><p>​我们可以将两者结合，先使用tar进行打包，然后使用gzip和bzip2进行压缩。</p><h4 id="压缩-tar-gz-tar-bz2-tgz"><a href="#压缩-tar-gz-tar-bz2-tgz" class="headerlink" title="压缩(.tar.gz .tar.bz2 .tgz)"></a>压缩(.tar.gz .tar.bz2 .tgz)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar 参数 生成压缩包的名字 要压缩的文件或目录（中间用空格隔开）</span><br><span class="line"><span class="comment"># 使用gzip，标准后缀格式为：.tar.gz</span></span><br><span class="line"><span class="comment"># 使用bzip2，标准后缀格式为：.tar.bz2</span></span><br></pre></td></tr></table></figure><ul><li>c：创建压缩文件</li><li>z：使用gzip的方式进行文件压缩</li><li>j：使用bzip2的方式进行文件压缩</li><li>v：压缩过程中显示压缩信息</li><li>f：指定压缩包的名字</li></ul><blockquote><p>一般认为.tgz文件就等同于.tar.gz 文件。</p></blockquote><p>将config文件夹与b.txt文件以gzip的方式进行压缩，得到a.tar.gz这个压缩包。</p><p><img src="/pic/image-20240302203635419.png" alt="image-20240302203635419"></p><h4 id="解压缩-tar-gz-tar-bz2-tgz"><a href="#解压缩-tar-gz-tar-bz2-tgz" class="headerlink" title="解压缩(.tar.gz .tar.bz2 .tgz)"></a>解压缩(.tar.gz .tar.bz2 .tgz)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#解压到当前目前</span><br><span class="line">tar 参数 压缩包名</span><br><span class="line"></span><br><span class="line">#解压到指定目录中</span><br><span class="line">tar 参数 压缩包名 -C 解压目录</span><br></pre></td></tr></table></figure><ul><li>x：释放压缩文件内容</li><li>z：使用gzip的方式进行文件压缩，压缩包后缀为.tar.gz</li><li>j：使用bzip2的方式进行文件压缩，压缩包后缀为.tar.bz2</li><li>v：解压缩过程中显示信息</li><li>f：指定压缩包的名字</li></ul><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ubuntu</span></span><br><span class="line">sudo apt install zip</span><br><span class="line">sudo apt install unzip</span><br><span class="line"><span class="comment">#CentOS</span></span><br><span class="line">sudo yum install zip</span><br><span class="line">sudo yum install unzip</span><br></pre></td></tr></table></figure><h4 id="压缩-zip"><a href="#压缩-zip" class="headerlink" title="压缩(.zip)"></a>压缩(.zip)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip [-r] 压缩包名 要压缩的文件</span><br></pre></td></tr></table></figure><h4 id="解压缩-zip"><a href="#解压缩-zip" class="headerlink" title="解压缩(.zip)"></a>解压缩(.zip)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unzip 压缩包名</span><br><span class="line"><span class="comment"># 压缩到指定目录</span></span><br><span class="line">unzip 压缩包名 -d 解压目录</span><br></pre></td></tr></table></figure><h3 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ubuntu</span></span><br><span class="line">sudo apt install rar</span><br></pre></td></tr></table></figure><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>根据文件的属性，查找对应的磁盘文件，比如文件名，文件类型，文件大小，文件的目录深度等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">find 搜索的路径 参数 搜索的内容</span><br><span class="line"><span class="comment"># -name 文件名，支持通配符?（单个）和*（多个），如find ./ -name &quot;*.cpp&quot;</span></span><br><span class="line"><span class="comment"># -type 文件类型</span></span><br><span class="line"><span class="comment"># -size 文件大小</span></span><br><span class="line"></span><br><span class="line">find / -maxdepth 5 -name <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"><span class="comment"># 搜索最多5层目录。同理还有 mindepth</span></span><br><span class="line"></span><br><span class="line">find 路径 参数 参数值 -<span class="built_in">exec</span> shell命令2 &#123;&#125; \;</span><br><span class="line"><span class="comment">#同时执行多个操作，将-exec替换为-ok，可以进行交互式操作。</span></span><br><span class="line"></span><br><span class="line">find 路径 参数 参数值 | xargs shell命令2</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240303210053582.png" alt="image-20240303210053582"></p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep命令用于查找文件里符合条件的字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;搜索的内容&quot;</span> 搜索的路径/文件 参数</span><br></pre></td></tr></table></figure><ul><li>-r：如果需要搜索目录。</li><li>-i：忽略大小写。</li><li>-n：显示行号。</li></ul><p><img src="/pic/image-20240303210754953.png" alt="image-20240303210754953"></p><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>功能与find类似，需要额外安装mlocate（ubuntu），不推荐。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++特性学习</title>
      <link href="/2024/03/15/C++%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/15/C++%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="const与constexpr"><a href="#const与constexpr" class="headerlink" title="const与constexpr"></a>const与constexpr</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>如果 <code>const</code> 变量的初始化值是常量表达式，那么它就是<strong>编译时常量</strong>。编译时常量使编译器能够执行非编译时常量无法提供的优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x &#123; <span class="number">3</span> &#125;;  <span class="comment">// x 是编译时常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y &#123; <span class="number">4</span> &#125;;  <span class="comment">// y 是编译时常量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; x + y; <span class="comment">// x + y 是编译时常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器编译时，它可以计算x+y的值，并将其替换为7。</p><p>任何用非常量表达式初始化的 <code>const</code> 变量都是<strong>运行时常量</strong>。运行时常量是在运行时才知道其初始化值的常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> z&#123;<span class="built_in">sum</span>(x, y)&#125;; <span class="comment">//运行时常量</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>当使用 <code>const</code> 时，变量最终可能是编译时的 <code>const</code> 或运行时的 <code>const</code>，这取决于初始化式是否是常量表达式。</p><p><code>constexpr</code>变量<strong>只能是编译时常量</strong>。如果 <code>constexpr</code> 变量的初始化值不是常量表达式，编译器将出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> z&#123;<span class="built_in">sum</span>(x, y)&#125;;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\23882\OneDrive\笔记\assets\image-20240312171839834.png" alt="image-20240312171839834"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/15/hello-world/"/>
      <url>/2024/03/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>黑群晖安装</title>
      <link href="/2024/03/15/%E9%BB%91%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85/"/>
      <url>/2024/03/15/%E9%BB%91%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="群晖引导u盘制作"><a href="#群晖引导u盘制作" class="headerlink" title="群晖引导u盘制作"></a>群晖引导u盘制作</h2><p>​在安装黑群晖之前，我们还需要安装一个u盘刷写工具。在官网<a href="https://rufus.ie/zh/">Rufus - 轻松创建 USB 启动盘</a>进行下载与安装。</p><p><img src="/pic/image-20240110131512593.png" alt="image-20240110131512593"></p><p>​下载对应平台的版本即可，我这里下载的是第一个。下载完Rufus后，我们需要下载群晖引导镜像。下载连接：<a href="https://github.com/fbelavenuto/arpl/releases">Releases · fbelavenuto&#x2F;arpl (github.com)</a><img src="/pic/image-20240110131806082.png" alt="image-20240110131806082"></p><p>​下载第一个即可<a href="https://github.com/fbelavenuto/arpl/releases/download/v1.1-beta2a/arpl-1.1-beta2a.img.zip">arpl-1.1-beta2a.img.zip</a>。这个github仓库里有这个群晖引导的制作者提供的官方教程，英语比较好的小伙伴也可以参考其中的步骤来进行安装。<a href="https://github.com/fbelavenuto/arpl">fbelavenuto&#x2F;arpl: Automated Redpill Loader (github.com)</a></p><p>​完成上面的步骤后，将用于制作群晖引导的u盘插入电脑。我这里选用的是kioxia64G的u盘。注意，请不要使用存有重要文件的u盘。用于制作引导的u盘会被格式化。这里建议买一个新的u盘，因为引导盘会被一直插在你的nas主机上。</p><p><img src="/pic/image-20240110132915711.png" alt="image-20240110132915711"></p><p>​选择你插入的u盘。</p><p><img src="/pic/image-20240110133007606.png" alt="image-20240110133007606"></p><p>​选择你下载好的群晖镜像文件。</p><p><img src="/pic/image-20240110133056062.png" alt="image-20240110133056062"></p><p>​然后点击开始，等待制作完成。</p><p><img src="/pic/image-20240110133151055.png" alt="image-20240110133151055"></p><p>​刷写完成，群晖引导就制作成功了，然后拔出u盘。</p><h2 id="群晖安装"><a href="#群晖安装" class="headerlink" title="群晖安装"></a>群晖安装</h2><p>​将引导u盘插入nas主机后开机。</p><img src="/pic/ea9b45e04e49ade108b2d46c474be9cf.jpg" alt="ea9b45e04e49ade108b2d46c474be9cf" style="zoom:25%;" /><p>​在bios里面选择u盘启动，每块主板的设置不一样，请自行查看主板型号后配置。</p><img src="/pic/image-20240111201844880.png" alt="image-20240111201844880" style="zoom: 25%;" /><p>​之后就会进行一系列的编译，运行。完成后就和我的界面一样。里面有一个ip地址。我们使用同一局域网下的另一台主机的游览器打开这个地址。</p><p><img src="/pic/image-20240111202103607.png" alt="image-20240111202103607"></p><p>​选择一个你要安装的型号</p><p><img src="/pic/image-20240111202237098.png" alt="image-20240111202237098"></p><p>​我这里的处理器是12代的，所以选择918或者920引导即可。然后选择你要安装的系统版本，选最新的就行了。</p><p>​注意：我在配置时，选择918的版本启动引导时，会卡在Boosting，可能是主板的原因。最终我选择了920的版本。</p><p><img src="/pic/image-20240111202430898.png" alt="image-20240111202430898"></p><p>​没有正版序列号，所以选择随机生成一个序列号。</p><p><img src="/pic/image-20240111202519753.png" alt="image-20240111202519753"></p><p>​不是10代处理器可以跳过这个设置。</p><p><img src="/pic/image-20240111202639730.png" alt="image-20240111202639730"></p><p>​以上的步骤进行完后，直接跳到Build the loader。开始编译引导。这时候开始下载需要的文件，你的NAS主机接入的网线必须有网！</p><p>如果和我一样网速比较慢可能需要下载十几分钟。</p><p><img src="/pic/image-20240111202749641.png" alt="image-20240111202749641"></p><p>​安装完成后，启动引导。</p><p><img src="/pic/image-20240111205412137.png" alt="image-20240111205412137"></p><p>​出现Booting后，代表引导成功启动。此时可以将连接在NAS主机的显示器断开。</p><p><img src="/pic/image-20240111205456892.png" alt="image-20240111205456892"></p><p>​通过群晖设备查找网站<a href="https://finds.synology.com/">Synology Web Assistant</a>，找到你局域网中的这台NAS。</p><p><img src="/pic/image-20240111220827514.png" alt="image-20240111220827514"></p><p>下载对应的DSM补丁。</p><p><img src="/pic/image-20240111220906768.png" alt="image-20240111220906768"></p><p>根据你的版本，选择合适的pat。我这里是DS920+，大小300多MB的是正常的，如果只有几mb，代表你下错了。下载完成后上传即可。</p><p><img src="/pic/image-20240111221248260.png" alt="image-20240111221248260"></p><p><img src="/pic/image-20240111221430930.png" alt="image-20240111221430930"></p><p>等待几分钟安装完成。</p><img src="/pic/image-20240111221552297.png" alt="image-20240111221552297" style="zoom:50%;" /><p><img src="/pic/image-20240111221728416.png" alt="image-20240111221728416"></p><p>​之后进行简单的配置即可。需要注意的是，<strong>一定不要选择自动更新！也不要添加账户！</strong>配置完成后进入到这个界面。</p><p><img src="/pic/image-20240111222422085.png" alt="image-20240111222422085"></p><p>​群晖成功安装！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> NAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2023/12/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/12/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>进入到<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a>，点击20.10.0 LTS，下载Node.js。</p><p><img src="/pic/image-20231230164706281.png" alt="image-20231230164706281"></p><p>下载完成后，打开文件进行安装，全部使用默认配置即可。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在命令行中输入如下命令，出现版本号即为安装成功。</p><p><img src="/pic/image-20231230165804389.png" alt="image-20231230165804389"></p><p>这里推荐设置阿里的国内镜像，方便后续的下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>新建一个用于存放博客的文件夹，我这里是E:\code\Blog。在这个文件夹内打开命令行。</p><p>安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230170248355.png" alt="image-20231230170248355"></p><p>初始化，此处需要用管理员身份运行cmd，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init .</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230170834292.png" alt="image-20231230170834292"></p><p>初始化完成后，文件夹内的结构如下</p><p><img src="/pic/image-20231230170908123.png" alt="image-20231230170908123"></p><p>然后依次输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建博客</span></span><br><span class="line">hexo new <span class="string">&quot;博客名&quot;</span></span><br><span class="line"><span class="comment"># 生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 打开本地服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230171152376.png" alt="image-20231230171152376"></p><p>可以看到，hexo 正在运行，点击下面的网址即可进入到自己搭建的博客中。<a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><p>此时的博客部署在本地，只有本机能访问。想要所有人都能访问，我们需要利用Github Pages的功能。</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>注册好一个github账号后，新建一个仓库。仓库的名字必须是 用户名.github.io，并且设置为Public</p><img src="/pic/image-20231230171535013.png" alt="image-20231230171535013" style="zoom:50%;" /><h3 id="推送到github"><a href="#推送到github" class="headerlink" title="推送到github"></a>推送到github</h3><p>修改配置文件_config.yml</p><p><img src="/pic/image-20231230171855053.png" alt="image-20231230171855053"></p><p>打开_config.yml后，拉到文件最下面。设置deploy，将repo设置成你创建的仓库即可。</p><p><img src="/pic/image-20231230180331594.png" alt="image-20231230180331594"></p><p>在配置好后，我们还需要进行一件事。</p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>将git与github账号绑定。打开git bash。输入如下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置用户名和邮箱</span></span><br><span class="line">git config --global user.name <span class="string">&quot;github 用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;github 注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230172750591.png" alt="image-20231230172750591"></p><p>然后生成ssh密钥文件。此前我已经生成过了，生成时直接一直回车就行了。然后打开文件所在的文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;github 注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230172911732.png" alt="image-20231230172911732"></p><p><img src="/pic/image-20231230173010019.png" alt="image-20231230173010019"></p><p>接着，我们打开github-setting-keys的页面。生成一个新的SSH key。</p><p><img src="/pic/image-20231230173148579.png" alt="image-20231230173148579"></p><p>将id_rsa.pub的内容复制到key中，然后点击add，就成功添加了。</p><p><img src="/pic/image-20231230173309738.png" alt="image-20231230173309738"></p><h2 id="完成搭建"><a href="#完成搭建" class="headerlink" title="完成搭建"></a>完成搭建</h2><p>安装hexo-deployer-git</p><p><img src="/pic/image-20231230180102177.png" alt="image-20231230180102177"></p><p>最后重启hexo即可完成搭建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h3><p>首先购买一个域名，我这里是在阿里云购买。</p><p><a href="https://wanwang.aliyun.com/">阿里云企航_万网域名_商标注册_资质备案_软件著作权_网站建设-阿里云 (aliyun.com)</a></p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>在github仓库新建一个CNAME文件，并且将你购买的域名填写进去后，提交修改。</p><p><img src="/pic/image-20231230181000266.png" alt="image-20231230181000266"></p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>添加两条记录</p><p><img src="/pic/image-20231230183246654.png" alt="image-20231230183246654"></p><p>等待10分钟后生效，可以直接通过你的域名进行访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
