<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>群晖虚拟机安装</title>
      <link href="/2024/03/15/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2024/03/15/%E7%BE%A4%E6%99%96%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="群晖虚拟机安装"><a href="#群晖虚拟机安装" class="headerlink" title="群晖虚拟机安装"></a>群晖虚拟机安装</h1><h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><p>首先在群晖套件中心下载Virtual Machine Manager</p><p><img src="/pic/image-20240228202835895.png" alt="image-20240228202835895"></p><p>然后下载你需要安装的系统镜像。博主这里需要学习linux的一些常见知识，所以打算安装Centos7和ubuntu20这两个系统。</p><p>Centos7:<a href="https://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/">centos-7.9.2009-isos-x86_64安装包下载_开源镜像站-阿里云 (aliyun.com)</a></p><p>Ubuntu20.04:<a href="https://mirrors.aliyun.com/ubuntu-releases/20.04/?spm=a2c6h.25603864.0.0.4e6b4ddafVxC0M">ubuntu-releases-20.04安装包下载_开源镜像站-阿里云 (aliyun.com)</a></p><p>下载完镜像后，上传到群晖中。</p><p>打开Virtual Machine Manager，然后点击新增。</p><p><img src="/pic/image-20240228210909220.png" alt="image-20240228210909220"></p><p>经过一系列配置后，将启动ISO文件选择为我们上传的系统镜像即可。</p><p><img src="/pic/image-20240228211013978.png" alt="image-20240228211013978"></p><p>最后启动虚拟机，进行centos系统的安装与配置即可。</p><h2 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h2><p>在同一个局域网内，我们使用另外一台电脑对群晖系统上的虚拟机进行连接。</p><p>首先，我们需要在虚拟机内安装ssh（如果没有）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure><p>然后我们开启默认端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>将我框出的语句的#删掉即可，然后保存并退出。</p><p><img src="/pic/image-20240301215914743.png" alt="image-20240301215914743"></p><p>最后重启SSH服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(ubuntu) sudo service ssh restart</span><br><span class="line">(centos7) service sshd restart</span><br></pre></td></tr></table></figure><p>输入命令，查看是否成功启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status sshd.service</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240301220247107.png" alt="image-20240301220247107"></p><p>最后，我们使用本地ssh连接群晖上的虚拟机。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@虚拟机ip地址</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240301220656918.png" alt="image-20240301220656918"></p><p>输入密码后即可成功连接。此方式需要虚拟机网络接口与群晖宿主机相同。</p><p><img src="/pic/image-20240301220755647.png" alt="image-20240301220755647"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux,NAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门（四）</title>
      <link href="/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%80/"/>
      <url>/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础入门（一）"><a href="#Linux基础入门（一）" class="headerlink" title="Linux基础入门（一）"></a>Linux基础入门（一）</h1><h2 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h2><p>Linux系统分为内核空间和用户空间。内核空间是Linux操作系统的主要部分，但是仅有内核的操作系统是不能完成用户任务的。丰富并且功能强大的应用程序包是一个操作系统成功的必要件。</p><p>Linux的内核主要由5个子系统组成：进程调度，内存管理，虚拟文件系统，网络接口，进程间通信。</p><p>进程调度 SCHED</p><ul><li>SCHED_OTHER：分时调度策略（默认），是用于针对普通进程的时间片轮转调度策略。</li><li>SCHED_FIFO：实时调度策略，是针对运行的实时性要求比较高，运行时间短的进程调度策略。</li><li>SCHED_RR：实时调度策略，是针对实时性要求比较高，运行时间比较长的进程调度策略。</li></ul><p>内存管理 MMU</p><ul><li>内存管理是多个进程间的内存共享策略。在Linux中，内存管理主要说的是虚拟内存。</li><li>虚拟内存可以让进程拥有比实际物理内存更大的内存，可以是实际内存的很多倍。</li><li>每个进程的虚拟内存有不同的地址空间，多个进程的虚拟内存不会冲突。</li></ul><p>虚拟文件系统 VFS</p><ul><li>在Linux下支持多种文件系统，如ext，ext2，minix，umsdos，msdos，vfat，ntfs等。</li><li>目前Linux下最常用的文件格式是ext2和ext3。</li></ul><p>网络接口</p><ul><li>Linux支持多种网络接口和协议。网络接口分为网络协议和驱动程序，网络协议是一种网络传输的通信标准，而网络驱动则是对硬件设备的驱动程序。Linux支持的网络设备多种多样，几乎目前所有网络设备都有驱动程序。</li></ul><p>进程间通信</p><ul><li>Linux操作系统支持多进程，进程之间需要进行数据的交流才能完成控制，协同工作等功能，Linux的进程间通信是从UNIX系统继承过来的。Linux下的进程间的通信方式主要有管道、信号量、消息队列、共享内存和套接字等方法。</li></ul><h2 id="Linux目录"><a href="#Linux目录" class="headerlink" title="Linux目录"></a>Linux目录</h2><h3 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h3><p><img src="/pic/image-20240229161709694.png" alt="image-20240229161709694"></p><p>在Linux中根目录的子目录结构相对是固定的（名字固定），不同的目录功能也是固定的</p><ul><li><p>bin: binary, 二进制文件目录, 存储了可执行程序, 今天要将的命令对应的可执行程序都在这个目录中</p></li><li><p>sbin: super binary, root用户使用的一些二进制可执行程序</p></li><li><p>etc: 配置文件目录, 系统的或者用户自己安装的应用程序的配置文件都存储在这个目录中</p></li><li><p>lib: library, 存储了一些动态库和静态库，给系统或者安装的软件使用</p></li><li><p>media: 挂载目录, 挂载外部设备，比如: 光驱, 扫描仪</p></li><li><p>mnt: 临时挂载目录, 比如我们可以将U盘临时挂载到这个目录下</p></li><li><p>proc: 内存使用的一个映射目录, 给操作系统使用的</p></li><li><p>tmp: 临时目录, 存放临时数据, 重启电脑数据就被自动删除了</p></li><li><p>boot: 存储了开机相关的设置</p></li><li><p>home: 存储了普通用户的家目录，家目录名和用户名相同</p></li><li><p>root: root用户的家目录</p></li><li><p>dev: device , 设备目录, Linux中一切皆文件, 所有的硬件会抽象成文件存储起来，比如：键盘， 鼠标</p></li><li><p>lost+found: 一般时候是空的, 电脑异常关闭&#x2F;崩溃时用来存储这些无家可归的文件, 用于用户系统恢复</p></li><li><p>opt: 第三方软件的安装目录</p></li><li><p>var: 存储了系统使用的一些经常会发生变化的文件， 比如：日志文件</p></li><li><p>usr: unix system resource, 系统的资源目录</p></li><li><ul><li><p>&#x2F;usr&#x2F;bin: 可执行的二进制应用程序</p></li><li><p>&#x2F;usr&#x2F;games: 游戏目录</p></li><li><p>&#x2F;usr&#x2F;include: 包含的标准头文件目录</p></li><li><p>&#x2F;usr&#x2F;local: 和opt目录作用相同, 安装第三方软件</p></li></ul></li></ul><h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>相对路径：相对路径就是相对于当前文件的路径。在Linux中有两个表示路径的特殊符号:</p><ul><li><p>.&#x2F;：代表目前所在的目录，也可以使用 .表示。</p></li><li><p>..&#x2F;：代表当前目录的上一层目录，也可以使用 ..表示。</p></li></ul><h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>绝对路径：从系统磁盘起始节点开始描述的路径。</p><ul><li><p>Linux：起始节点为根目录，比如： &#x2F;root&#x2F;os。</p></li><li><p>Windows: 起始节点为某个磁盘的盘符。</p></li></ul><h2 id="命令解析器"><a href="#命令解析器" class="headerlink" title="命令解析器"></a>命令解析器</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Linux终端是如何识别并且运行那些用户输入的命令的呢？这些命令都是通过命令解析器解析完成并执行的。</p><p>命令解析器是在Linux操作系统中就是一个进程，叫做bash。其工作的具体步骤如下：</p><p>在Linux中有一个叫叫做PATH的环境变量，里面存储了一些系统目录。我们可以通过echo $PATH命令查看。</p><p><img src="/pic/image-20240229162538698.png" alt="image-20240229162538698"></p><p>命令解析器需要依次搜索PATH中的各个目录，检查这些目录是否有用户输入的指令。</p><ul><li>如果找到了，执行该目录下的可执行程序，用户输入的命令就被执行完毕了。</li><li>如果没有找到，继续搜索其他目录，最后还是没有找到，会提示命令找不到。</li></ul><h3 id="命令提示行"><a href="#命令提示行" class="headerlink" title="命令提示行"></a>命令提示行</h3><p><img src="/pic/image-20240229162904645.png" alt="image-20240229162904645"></p><ul><li>krito:当前登录的用户的用户名</li><li>@:在</li><li>localhost：主机名，在安装Linux操作系统时手动指定，可以修改、</li><li>~：当前用户的家目录</li><li>#：代表当前用户是root用户</li><li>$：代表当前用户是普通用户。</li></ul><h3 id="命令行快捷键"><a href="#命令行快捷键" class="headerlink" title="命令行快捷键"></a>命令行快捷键</h3><table><thead><tr><th align="left"><strong>快捷键</strong></th><th align="left"><strong>功能</strong></th><th align="left"><strong>备注</strong></th></tr></thead><tbody><tr><td align="left">Tab</td><td align="left">命令自动补齐</td><td align="left">在终端中输入某个命令的前一个或若干个字符，再按Tab键</td></tr><tr><td align="left">Ctrl+p</td><td align="left">显示输入的上一个历史命令</td><td align="left">从输入的最后一个命令往前倒，也可以使用↑键</td></tr><tr><td align="left">Ctrl+n</td><td align="left">显示输入的下一个历史命令</td><td align="left">也可以使用↓键</td></tr><tr><td align="left">Ctrl+a</td><td align="left">光标移动命命令行首</td><td align="left">也可以使用Home键</td></tr><tr><td align="left">Ctrl+e</td><td align="left">光标移动命命令行尾</td><td align="left">也可以使用End键</td></tr><tr><td align="left">Ctrl+u</td><td align="left">删除光标前的部分字符串</td><td align="left">无</td></tr><tr><td align="left">Ctrl+k</td><td align="left">删除光标后的部分字符串</td><td align="left">无</td></tr><tr><td align="left">→</td><td align="left">光标向右移动一个字符</td><td align="left">无</td></tr><tr><td align="left">←</td><td align="left">光标向左移动一个字符</td><td align="left">无</td></tr><tr><td align="left">Backspace&#x2F;Delete</td><td align="left">删除光标前&#x2F;后的一个字符</td><td align="left">无</td></tr></tbody></table><h2 id="文件管理命令"><a href="#文件管理命令" class="headerlink" title="文件管理命令"></a>文件管理命令</h2><h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><p>进入指定目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目录名</span><br></pre></td></tr></table></figure><ul><li>目录名：使用相对路径&#x2F;绝对路径都可以</li><li>特色目录：..表示当前目录的上一级目录，使用cd .. 或者cd ..&#x2F;都可以；.表示当前目录，cd . 不会切换目录。</li></ul><p>进入家目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span>                    <span class="comment"># 方式1</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> ~                  <span class="comment"># 方式2</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /home/用户名        <span class="comment"># 方式3</span></span></span><br></pre></td></tr></table></figure><p>在临近的两个目录之间切换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> -</span></span><br></pre></td></tr></table></figure><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><h4 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a>用户类型</h4><p>在Linux中有三大类用户：文件所有者，文件所属组用户，其他人，我们可以对同一个文件给这三种人设置不同的操作权限。</p><ul><li>文件所有者：Linux中的所有的文件都有一个所有者，就是文件的主人。</li><li>文件所属组：</li></ul><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>权限一共有四种：读权限，写权限，执行权限，无权限。</p><ul><li>读权限：使用r表示，即：read。</li><li>写权限：使用w表示，即：write。</li><li>执行权限：使用x表示，即：excute。</li><li>没有任何权限：使用-表示。</li></ul><p><img src="/pic/image-20240301185538543.png" alt="image-20240301185538543"></p><p>第一个字符为文件类型，接下来每三个字符分别代表的是文件所有者，文件所属组用户，其他人对文件的操作权限。这个例子里，所有用户都对文件有读、写、执行权限。</p><h4 id="硬链接计数"><a href="#硬链接计数" class="headerlink" title="硬链接计数"></a>硬链接计数</h4><p>每当我们给磁盘文件创建一个硬链接（使用ln），磁盘上就会出现一个新的文件名，硬链接技术加1，但是这新文件并不占用任何的磁盘空间，文件名还是映射到原来的磁盘地址上。</p><ul><li>和直接进行文件拷贝的区别是，创建硬链接只是多了一个新的文件名，拷贝文件不仅多了新的文件名，在磁盘上数据也进行了拷贝。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> 文件A 文件B</span><br></pre></td></tr></table></figure><h3 id="创建删除目录"><a href="#创建删除目录" class="headerlink" title="创建删除目录"></a>创建删除目录</h3><p>创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单层目录</span></span><br><span class="line"><span class="built_in">mkdir</span> 新目录名字</span><br><span class="line"></span><br><span class="line"><span class="comment">#多层目录，需要加参数 -p</span></span><br><span class="line"> <span class="built_in">mkdir</span> root/a/b/c -p</span><br></pre></td></tr></table></figure><p>删除目录</p><p>如果要删除已经存在的路径，可以使用rmdir或者rm</p><ul><li>rmdir：只能删除空目录</li><li>rm：可以删除文件也可以删除目录，如果要删除目录，需要加参数-r。(recursion)</li></ul><p>rm命令常用参数:</p><ul><li>-i：删除的时候给提示</li><li>-f：强制删除文件，没有提示直接删除并且不能恢复。</li></ul><h3 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h3><p> 拷贝文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 要拷贝的文件 得到的文件</span><br></pre></td></tr></table></figure><p>拷贝目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> 文件A 文件B -r</span><br></pre></td></tr></table></figure><h3 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h3><p>文件的移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mv 要移动的文件 目录</span></span><br><span class="line"><span class="comment">#把文件A移动到目录B中</span></span><br><span class="line"><span class="built_in">mv</span> A B</span><br></pre></td></tr></table></figure><p>文件改名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mv 要改名的文件 新名字（必须是原来不存在的）</span></span><br><span class="line"><span class="comment"># 其中A可以是文件也可以是目录，并且是存在的，B原来是不存在的</span></span><br><span class="line"><span class="built_in">mv</span> A B</span><br></pre></td></tr></table></figure><p>文件覆盖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#mv 存在的文件A 存在的文件B</span></span><br><span class="line"><span class="comment"># A文件中的内容覆盖B文件中的内容，A文件被删除，只剩下B文件。</span></span><br><span class="line"><span class="built_in">mv</span> A B</span><br></pre></td></tr></table></figure><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><p>cat，将文件内容显示到终端，如果文件太大则无法完全显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 文件名</span><br></pre></td></tr></table></figure><p>more，可以翻屏查看文件中的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">more 文件名</span><br><span class="line">快捷键</span><br><span class="line">- 回车：显示下一行</span><br><span class="line">- 空格：向下滚动一屏</span><br><span class="line">- b：返回上一屏</span><br><span class="line">- q：退出</span><br></pre></td></tr></table></figure><p>less，和more相似。</p><p>head，查看文件头部的若干行信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认显示文件的前10行</span></span><br><span class="line"><span class="built_in">head</span> -行数 文件名</span><br></pre></td></tr></table></figure><p>tail，查看文件尾部的若干行信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -行数 文件名</span><br></pre></td></tr></table></figure><h3 id="连接的创建"><a href="#连接的创建" class="headerlink" title="连接的创建"></a>连接的创建</h3><p>连接分两种类型：软链接和硬链接。软链接相当于windows中的快捷方式，硬链接文件并不会进行拷贝，只是多出一个新的文件名并且硬链接计数会加1。</p><h4 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s 源文件路径（建议使用绝对路径） 软连接文件名</span><br></pre></td></tr></table></figure><p>a.lnk为相对路径</p><p><img src="/pic/image-20240301210140554.png" alt="image-20240301210140554"></p><p>我们将其移动后，a.lnk变成红色，变为不可用。</p><p><img src="/pic/image-20240301210227851.png" alt="image-20240301210227851"></p><p>a.lnk指向当前目录下的a.txt，所有推荐使用绝对路径。</p><p><img src="/pic/image-20240301210344584.png" alt="image-20240301210344584"></p><h4 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln 源文件 硬链接文件名</span><br></pre></td></tr></table></figure><p>硬链接与软链接不同，它是通过文件名直接找对应的硬盘地址，而不是基于路径，所以源文件直接使用相对路径即可，无需指定绝对路径。目录不允许创建硬链接。</p><h3 id="文件权限-1"><a href="#文件权限-1" class="headerlink" title="文件权限"></a>文件权限</h3><h4 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#chmod</span></span><br><span class="line"><span class="comment">#语法格式: chmod who[+|-|=]mod 文件名</span></span><br><span class="line">- <span class="built_in">who</span>:</span><br><span class="line">- u: user  -&gt; 文件所有者</span><br><span class="line">- g: group -&gt; 文件所属组用户</span><br><span class="line">- o: other -&gt; 其他</span><br><span class="line">- a: all, 以上是三类人 u+g+o</span><br><span class="line">- 对权限的操作:</span><br><span class="line">+: 添加权限</span><br><span class="line">-: 去除权限</span><br><span class="line">=: 权限的覆盖</span><br><span class="line">- mod: 权限</span><br><span class="line">r: <span class="built_in">read</span>, 读</span><br><span class="line">w: write, 写</span><br><span class="line">x: execute, 执行</span><br><span class="line">-: 没有权限</span><br></pre></td></tr></table></figure><p>给所有人读、写、执行权限</p><p><img src="/pic/image-20240301211913336.png" alt="image-20240301211913336"></p><p>去除文件所有者的执行权限</p><p><img src="/pic/image-20240301212023920.png" alt="image-20240301212023920"></p><h4 id="修改文件所有者"><a href="#修改文件所有者" class="headerlink" title="修改文件所有者"></a>修改文件所有者</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#只修改所有者</span></span><br><span class="line">sudo <span class="built_in">chown</span> 新的所有者 文件名</span><br><span class="line"><span class="comment">#同时修改所有者和所属组</span></span><br><span class="line">sudo <span class="built_in">chown</span> 新的所有者:新的组名 文件名</span><br></pre></td></tr></table></figure><p>修改文件所有者为root。</p><p><img src="/pic/image-20240301213427378.png" alt="image-20240301213427378"></p><h4 id="修改文件所属组"><a href="#修改文件所属组" class="headerlink" title="修改文件所属组"></a>修改文件所属组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chgrp</span> 新的组名 文件名</span><br></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><h4 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h4><p>显示当前用户所在的工作目录</p><p><img src="/pic/image-20240301213934756.png" alt="image-20240301213934756"></p><h4 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h4><p>创建一个新的空文件，如果指定文件已存在，只会更新该文件的修改日期，对内容没有任何影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> 文件名</span><br></pre></td></tr></table></figure><h4 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h4><p>查看要执行的命令所在的实际路径。</p><p><img src="/pic/image-20240301214624620.png" alt="image-20240301214624620"></p><h4 id="重定向命令"><a href="#重定向命令" class="headerlink" title="重定向命令"></a>重定向命令</h4><p>输出重定向：修改输出的数据的位置。将原来显示在终端的数据输入到文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;:将输出的内容写入到指定文件中，如果文件中已有数据，则会使用新数据覆盖。</span><br><span class="line">&gt;&gt;:将输出的内容追加到指定文件尾部。</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240301221224690.png" alt="image-20240301221224690"></p><h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只切换用户，工作目录不变</span></span><br><span class="line">su 用户名</span><br><span class="line"><span class="comment"># 切换用户和工作目录，会自动跳转到当前用户的家目录中</span></span><br><span class="line">su - 用户名</span><br><span class="line"><span class="comment"># 回到原来的用户</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h3 id="添加删除用户"><a href="#添加删除用户" class="headerlink" title="添加删除用户"></a>添加删除用户</h3><h4 id="添加新用户"><a href="#添加新用户" class="headerlink" title="添加新用户"></a>添加新用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加用户</span></span><br><span class="line">sudo adduser 用户名</span><br><span class="line"><span class="comment"># centos</span></span><br><span class="line">sudo useradd 用户名</span><br><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">sudo useradd -m -s /bin/bash 用户名</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240302135738891-1709359060351-1.png" alt="image-20240302135738891"></p><p>centos创建用户后，需要更改用户密码。</p><p><img src="/pic/image-20240302135811122.png" alt="image-20240302135811122"></p><p>修改完密码后，使用新密码登入新用户。</p><p><img src="/pic/image-20240302135844711.png" alt="image-20240302135844711"></p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除用户，添加参数 -r 就可以一并删除用户的家目录</span></span><br><span class="line">sudo userdel 用户名 -r</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240302140407309.png" alt="image-20240302140407309"></p><h3 id="添加和删除用户组"><a href="#添加和删除用户组" class="headerlink" title="添加和删除用户组"></a>添加和删除用户组</h3><p>默认情况下，只要创建新用户就会得到一个同名的用户组，并且这个用户属于这个组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd 组名</span><br><span class="line">sudo groupdel 组名</span><br></pre></td></tr></table></figure><p>在&#x2F;etc&#x2F;group文件中，查看所有的用户组。</p><p><img src="/pic/image-20240302141003188.png" alt="image-20240302141003188"></p><p><img src="/pic/image-20240302140948482.png" alt="image-20240302140948482"></p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改当前用户密码</span></span><br><span class="line">passwd</span><br><span class="line"><span class="comment"># 修改非当前用户密码</span></span><br><span class="line">sudo passwd 用户名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门（四）</title>
      <link href="/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%9B%9B/"/>
      <url>/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>Makefile的框架由规则构成。make命令执行时先在Makefile文件中查找各种规则，对各种规则进行解析后运行规则。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每条规则的语法格式：</span></span><br><span class="line"><span class="section">target1,target2...: depend1, depend2, ...</span></span><br><span class="line">command</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>每条规则由三个部分组成，分别是目标(target)，依赖(depend)和命令(command)。</p><ul><li>命令(command)：当前这条规则的动作，一般情况下是一个shell命令。<ul><li>例如：通过某个命令编译文件，生成库文件，进入目录等。</li><li>动作可以是多个，每个命令前必须有一个tab并且独占一行</li></ul></li><li>依赖(depend)：规则所必需的依赖条件，在规则的命令中可以使用这些依赖。<ul><li>可以为空，可以是其他规则中的某个目标，可以指定多个。</li></ul></li><li>目标(target)：规则中的目标，这个目标和规则中的命令是对应的<ul><li>通过执行命令，可以生成一个和目标同名的文件。</li><li>规则中可以有多个命令，因此可以有多个目标。</li></ul></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单个目标，单个命令</span></span><br><span class="line"><span class="section">app:a.c b.c c.c</span></span><br><span class="line">gcc a.c b.c c.c -o app</span><br><span class="line"></span><br><span class="line"><span class="comment">#多个目标，多个命令</span></span><br><span class="line"><span class="section">app,app1:a.c b.c c.c d.c</span></span><br><span class="line">gcc a.c b.c -o app</span><br><span class="line">gcc c.c d.c -o app1</span><br><span class="line"></span><br><span class="line"><span class="comment">#规则之间的嵌套</span></span><br><span class="line"><span class="section">app:a.o b.o c.o</span></span><br><span class="line">gcc a.o b.o c.o -o app</span><br><span class="line"><span class="section">a.o:a.c</span></span><br><span class="line">gcc -c a.c</span><br><span class="line"><span class="section">b.o:b.c</span></span><br><span class="line">gcc -c b.c</span><br><span class="line"><span class="section">c.o:c.c</span></span><br><span class="line">gcc -c c.c</span><br></pre></td></tr></table></figure><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="文件时间戳"><a href="#文件时间戳" class="headerlink" title="文件时间戳"></a>文件时间戳</h3><p>make命令执行时会根据文件的时间戳判定是否执行makefile文件中相关规则的命令。</p><ul><li>目标是通过依赖生成，所以正常情况下：目标时间戳&gt;所有依赖的时间戳，如果执行make命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不被执行。</li><li>当依赖文件被更新时，目标时间戳&lt;某些依赖的时间戳，在这种情况下目标文件会被重新生成。</li><li>如果目标文件不存在，规则中的命令看到会被执行。</li></ul><h3 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h3><p>make有自动推导的能力，不会完全依赖makefile。</p><p>makefile内容：</p><p><img src="/pic/image-20240309205941666.png" alt="image-20240309205941666"></p><p><img src="/pic/image-20240309210136746.png" alt="image-20240309210136746"></p><p><img src="/pic/image-20240309210002712.png" alt="image-20240309210002712"></p><p>前五条命令为make自动推导的结果。</p><h1 id="GBD"><a href="#GBD" class="headerlink" title="GBD"></a>GBD</h1><h2 id="调试准备"><a href="#调试准备" class="headerlink" title="调试准备"></a>调试准备</h2><p>生成可用于调试的可执行文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -g -Wall -O0 -o app</span><br></pre></td></tr></table></figure><p> 使用gdb 进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb app</span><br></pre></td></tr></table></figure><p>设置命令行参数</p><p><img src="/pic/image-20240310124549878.png" alt="image-20240310124549878"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行到第一个断点，如果没有设置断点，程序直接执行完</span></span><br><span class="line">run</span><br><span class="line"><span class="comment"># 启动程序，最终会阻塞在main函数第一行</span></span><br><span class="line">start</span><br><span class="line"><span class="comment"># 退出gdb</span></span><br><span class="line">quit/q</span><br></pre></td></tr></table></figure><p>run命令，没有断点则直接执行完程序。</p><p><img src="/pic/image-20240310124737571.png" alt="image-20240310124737571"></p><h2 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h2><p>当前文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从第一行开始显示</span></span><br><span class="line">(gdb) list </span><br><span class="line"></span><br><span class="line"><span class="comment"># 列值这行号对应的上下文代码, 默认情况下只显示10行内容</span></span><br><span class="line">(gdb) list 行号</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示这个函数的上下文内容, 默认显示10行</span></span><br><span class="line">(gdb) list 函数名</span><br></pre></td></tr></table></figure><p>切换文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l 文件名:行号</span><br><span class="line"></span><br><span class="line">l 文件名:函数名</span><br></pre></td></tr></table></figure><p>设置显示的行数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两个命令中的 listsize 都可以写成 list</span></span><br><span class="line"><span class="built_in">set</span> listsize 行数</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前list一次显示的行数</span></span><br><span class="line">show listsize</span><br></pre></td></tr></table></figure><h2 id="断点操作"><a href="#断点操作" class="headerlink" title="断点操作"></a>断点操作</h2><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>断点的设置有两种方式，一种是常规断点，程序只要运行到这个位置就会被阻塞；还有一种叫条件断点，只有指定的条件被满足了程序才会在断点处阻塞。</p><p>设置普通断点到当前文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前文件的某一行上设置断点</span></span><br><span class="line"><span class="comment"># break = b</span></span><br><span class="line">b 行号</span><br><span class="line">b 函数名</span><br></pre></td></tr></table></figure><p>设置普通断点到某个非当前文件上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在非当前文件的某一行上设置断点</span></span><br><span class="line">b 文件名:行号</span><br><span class="line">b 文件名:函数名</span><br></pre></td></tr></table></figure><p>设置条件断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b  行数 <span class="keyword">if</span> 变量名==某个值</span><br></pre></td></tr></table></figure><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info breakpoint</span><br><span class="line">i b</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310141015418.png" alt="image-20240310141015418"></p><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># delete == del == d</span></span><br><span class="line">d 断点的编号1 [断点编号2 ...]</span><br><span class="line">d 1</span><br><span class="line">d 2 4 6</span><br><span class="line">d 1-5</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310141215534.png" alt="image-20240310141215534"></p><h3 id="设置断点状态"><a href="#设置断点状态" class="headerlink" title="设置断点状态"></a>设置断点状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#设置断点无效</span><br><span class="line"># disable == dis</span><br><span class="line">#设置某一个或者某几个断点无效</span><br><span class="line">dis 断点1的编号</span><br><span class="line">dis 1-5</span><br><span class="line">#生效enable = ena</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310141418525.png" alt="image-20240310141418525"></p><p>编号6的断点Ebh变为n</p><p><img src="/pic/image-20240310141454631.png" alt="image-20240310141454631"></p><h2 id="调试命令"><a href="#调试命令" class="headerlink" title="调试命令"></a>调试命令</h2><p>继续运行gdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># continue = c</span></span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure><p> 打印变量值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># print = p</span><br><span class="line">p 变量名</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310144055829.png" alt="image-20240310144055829"></p><p>打印变量类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptype 变量名</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310144313726.png" alt="image-20240310144313726"></p><p>自动打印信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">display 变量名</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310144547924.png" alt="image-20240310144547924"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除自动显示</span></span><br><span class="line">delete display num</span><br><span class="line"><span class="comment">#停用</span></span><br><span class="line"><span class="built_in">disable</span> display num</span><br><span class="line"><span class="comment">#启用</span></span><br><span class="line"><span class="built_in">enable</span> display num</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310144716007.png" alt="image-20240310144716007"></p><h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><p>执行下一行，如果是函数调用，则会进入到函数体内部。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># step == s</span></span><br><span class="line">step</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310154958050.png" alt="image-20240310154958050"></p><p>跳出函数体</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finish</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310155040279.png" alt="image-20240310155040279"></p><p>执行下一行，不会进入函数体内部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#next == n</span></span><br><span class="line">next</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310155100436.png" alt="image-20240310155100436"></p><p>跳出循环体。循环体内无有效断点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">until</span></span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240310155922854.png" alt="image-20240310155922854"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门（三）</title>
      <link href="/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%89/"/>
      <url>/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础入门（三）"><a href="#Linux基础入门（三）" class="headerlink" title="Linux基础入门（三）"></a>Linux基础入门（三）</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p>GCC是Linux下的编译工具集，是GNU Compiler Collection的缩写，包含gcc、g++等编译器，这个工具集不仅包含编译器，还包含其他工具集，例如ar、nm等。</p><h3 id="安装GCC"><a href="#安装GCC" class="headerlink" title="安装GCC"></a>安装GCC</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ubuntu</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install gcc g++</span><br><span class="line"></span><br><span class="line">centos</span><br><span class="line">sudo yum update</span><br><span class="line">sudo yum install gcc g ++</span><br><span class="line"></span><br><span class="line">查看gcc版本</span><br><span class="line">gcc -v</span><br><span class="line"></span><br><span class="line">查看g++版本</span><br><span class="line">g++ -v</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240307124527126.png" alt="image-20240307124527126"></p><h3 id="gcc工作流程"><a href="#gcc工作流程" class="headerlink" title="gcc工作流程"></a>gcc工作流程</h3><p>GCC编译器对程序的编译分为四个阶段：预处理（预编译）、编译和优化、汇编和链接。GCC编译器可以将这四个步骤合并成一个。</p><p>1.预处理：GCC调用预处理器来完成；展开头文件、宏替换、去掉注释行。</p><p>2.编译：GCC调用编译器对文件进行编译，最终得到一个汇编文件。</p><p>3.汇编：GCC调用汇编器对文件进行汇编，最终得到一个二进制文件。</p><p>4.链接：GCC调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件。</p><table><thead><tr><th>文件名后缀</th><th>说明</th><th>gcc参数</th></tr></thead><tbody><tr><td>.c</td><td>源文件</td><td>无</td></tr><tr><td>.i</td><td>预处理后的C文件</td><td>-E</td></tr><tr><td>.s</td><td>编译之后得到的汇编语言的源文件</td><td>-S</td></tr><tr><td>.o</td><td>汇编后得到的二进制文件</td><td>-c</td></tr></tbody></table><p><img src="/pic/image-20240307125904722.png" alt="image-20240307125904722"></p><p>test.c</p><p><img src="/pic/image-20240307130209517.png" alt="image-20240307130209517"></p><p>test.i</p><p><img src="/pic/image-20240307130150335.png" alt="image-20240307130150335"></p><p>test.s</p><p><img src="/pic/image-20240307130412927.png" alt="image-20240307130412927"></p><p>test.o</p><p><img src="/pic/image-20240307130516326.png" alt="image-20240307130516326"></p><p>最后运行</p><p><img src="/pic/image-20240307130552101.png" alt="image-20240307130552101"></p><p>我们也可以直接gcc test.c -o test。</p><h3 id="gcc常用参数"><a href="#gcc常用参数" class="headerlink" title="gcc常用参数"></a>gcc常用参数</h3><h4 id="指定生成的文件名-o"><a href="#指定生成的文件名-o" class="headerlink" title="指定生成的文件名(-o)"></a>指定生成的文件名(-o)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o 生成文件名</span><br></pre></td></tr></table></figure><h4 id="搜索头文件-l"><a href="#搜索头文件-l" class="headerlink" title="搜索头文件(-l)"></a>搜索头文件(-l)</h4><p>指定要引用的头文件路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c -I include</span><br></pre></td></tr></table></figure><h4 id="指定一个宏-D"><a href="#指定一个宏-D" class="headerlink" title="指定一个宏(-D)"></a>指定一个宏(-D)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 源文件 -D 宏定义</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240307161527012.png" alt="image-20240307161527012"></p><p>gcc test.c</p><p><img src="/pic/image-20240307161611531.png" alt="image-20240307161611531"></p><p><img src="/pic/image-20240307161715163.png" alt="image-20240307161715163"></p><h3 id="gcc和g"><a href="#gcc和g" class="headerlink" title="gcc和g++"></a>gcc和g++</h3><p>gcc无法自动链接到c++标准库，需要指定参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.cpp -l stdc++</span><br></pre></td></tr></table></figure><h2 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h2><h3 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h3><p>在Linux中静态库由程序ar生成。</p><ul><li>在Linux中静态库以lib作为前缀，以.a作为后缀，中间是库的名字，即：libxxx.a</li><li>在Windows中静态库一般以lib作为前缀，以lib作为后缀，中间是库的名字，即：libxxx.lib</li></ul><h4 id="生成静态库"><a href="#生成静态库" class="headerlink" title="生成静态库"></a>生成静态库</h4><p>生成静态库，需要先对源文件进行汇编操作得到二进制格式的目标文件，然后再通过ar工具将目标文件打包就可以得到静态库文件了。</p><ul><li>参数c：创建一个库。</li><li>参数s：创建目标文件索引，在创建较大的库时能加快时间。</li><li>参数r：在库中插入模块（替换）。</li></ul><p>生成静态链接库的具体步骤如下：</p><p>1.需要将源文件进行汇编，得到.o文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行如下操作，默认生成二进制的.o文件</span></span><br><span class="line">gcc 源文件(*.c) -c </span><br></pre></td></tr></table></figure><p> 2.将得到的.o进行打包，得到静态库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs 静态库的名字 原材料(*.o)</span><br></pre></td></tr></table></figure><p>sub.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>head.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _HEAD_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">multiply</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">double</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">12</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, add(a, b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a - b = %d\n&quot;</span>, subtract(a, b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a * b = %d\n&quot;</span>, multiply(a, b));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a / b = %f\n&quot;</span>, divide(a, b));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240309150724507.png" alt="image-20240309150724507"></p><p><img src="/pic/image-20240309151809802.png" alt="image-20240309151809802"></p><p><img src="/pic/image-20240309151904844.png" alt="image-20240309151904844"></p><p><img src="/pic/image-20240309152344807.png" alt="image-20240309152344807"></p><h3 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h3><p>动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在Linux中动态链接库也可以称之为共享库。</p><ul><li>在Linux中动态库以lib作为前缀，以.so作为后缀，中间是库的名字，例如：libxxx.so</li><li>在Windows中动态库一般以lib作为前缀，以dll作为后缀，中间是库的名字，例如：libxxx.dll</li></ul><p> </p><h4 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h4><p>直接使用gcc命令并且需要添加-fPIC（-fpic）以及-shared参数。</p><ul><li>-fPIC或-fpic参数的作用是使得gcc生成的代码是与位置无关的，也就是使用相对位置。</li><li>-shared参数是告诉编译器生成一个动态链接库</li></ul><p>生成动态链接库的具体步骤如下：</p><p>1.将源文件进行汇编操作、需要使用参数-c，还需要添加额外此参数 -fpic&#x2F;-fPIC</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">得到若干个 .o文件</span><br><span class="line">gcc 源文件(*.c) -c -fpic</span><br></pre></td></tr></table></figure><p>2.将得到的.o文件打包成动态库，还是使用gcc，使用参数 -shared 指定生成动态库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so)</span><br></pre></td></tr></table></figure><p>3.发布动态库和头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.提供头文件：xxx.h</span><br><span class="line">2.提供动态库：libxxx.so</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240309152830627.png" alt="image-20240309152830627"></p><p><img src="/pic/image-20240309152810286.png" alt="image-20240309152810286"></p><p><img src="/pic/image-20240309153126857.png" alt="image-20240309153126857"></p><p><img src="/pic/image-20240309153111078.png" alt="image-20240309153111078"></p><h4 id="解决动态库无法加载问题"><a href="#解决动态库无法加载问题" class="headerlink" title="解决动态库无法加载问题"></a>解决动态库无法加载问题</h4><h5 id="库的工作原理"><a href="#库的工作原理" class="headerlink" title="库的工作原理"></a>库的工作原理</h5><ul><li><p>静态库加载</p><p>静态库会被打包到可执行程序中，当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。</p></li><li><p>动态库加载</p><p>gcc命令中虽然指定了库路径（-L），但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。</p><p>动态库文件没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。</p></li></ul><p>可执行程序被执行后，会先检测需要的动态库是否可以被加载，加载不到就会提示错误信息。</p><p>当动态库中的函数在程序中被调用了，这时候动态库才加载到内存，如果不被调用就不加载。</p><p>动态库的检测和内存加载操作都是由动态连接器来完成的。</p><h5 id="动态链接器"><a href="#动态链接器" class="headerlink" title="动态链接器"></a>动态链接器</h5><p>动态链接器是一个独立的进程，当用户的程序需要加载动态库时，动态链接器开始工作。</p><p>动态链接器的搜索顺序：</p><p>1.可执行文件内部的DT_RPATH段</p><p>2.系统的环境变量LD_LIBRARY_PATH</p><p>3.系统动态库的缓存文件&#x2F;etc&#x2F;ld.so.cache</p><p>4.存储动态库 &#x2F; 静态库的系统目录 &#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib等</p><p>如果按照上面四个顺序搜索，最后还是没找到，动态链接器就会提示错误信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd 可执行文件 <span class="comment">#检查可执行文件所需的动态库能否被正确加载</span></span><br></pre></td></tr></table></figure><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p>方案1：将库路径添加到环境变量LD_LIBRARY_PATH中</p><p>1.找到配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/.bashrc 对当前用户有效</span><br><span class="line">/etc/profile 对所有用户有效</span><br></pre></td></tr></table></figure><p>2.使用vim打开配置文件，在文件最后添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:动态库的绝对路径</span><br></pre></td></tr></table></figure><p>3.配置文件生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc          (. ~/.bashrc)</span><br><span class="line"><span class="built_in">source</span> /etc/profile       (. /etc/profile)</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240309154359422.png" alt="image-20240309154359422"></p><p><img src="/pic/image-20240309154412551.png" alt="image-20240309154412551"></p><p>方案2: 更新 &#x2F;etc&#x2F;ld.so.cache 文件</p><ol><li><p>找到动态库所在的绝对路径 比如：<code>/home/krito/Library/</code></p></li><li><p>修改 <code>/etc/ld.so.conf</code>，将路径添加到该文件末尾。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/ld.so.conf</span><br></pre></td></tr></table></figure></li><li><p>更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure></li></ol><p>方案3: 拷贝动态库文件到系统库目录 <code>/lib/</code> 或者 <code>/usr/lib</code> 中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 库拷贝</span></span><br><span class="line">sudo <span class="built_in">cp</span> /xxx/xxx/libxxx.so /usr/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建软连接</span></span><br><span class="line">sudo <span class="built_in">ln</span> -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240309154814930.png" alt="image-20240309154814930"></p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>静态库优点：</p><ul><li>静态库被打包到应用程序中，加载速度更快</li><li>发布程序无需提供静态库，移植方便</li></ul><p>静态库缺点：</p><ul><li>相同的库文件可能会在内存中加载多份，消耗系统资源，浪费内存。</li><li>库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间。</li></ul><p>动态库优点：</p><ul><li>可实现不同进程间的资源共享</li><li>动态库升级简单，只需要替换库文件，无需重新编译应用程序</li><li>可控制何时加载</li></ul><p>动态库缺点：</p><ul><li>加载速度比静态库慢</li><li>发布程序需要提供依赖的动态库</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础入门（二）</title>
      <link href="/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%BA%8C/"/>
      <url>/2024/03/15/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础入门（二）"><a href="#Linux基础入门（二）" class="headerlink" title="Linux基础入门（二）"></a>Linux基础入门（二）</h1><h2 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h2><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><p>​tar是打包工具，不能压缩文件。gzip和bzip2，不能打包压缩文件，每个文件都会生成一个单独的压缩包，并且压缩之后不会保留原文件。</p><p>​我们可以将两者结合，先使用tar进行打包，然后使用gzip和bzip2进行压缩。</p><h4 id="压缩-tar-gz-tar-bz2-tgz"><a href="#压缩-tar-gz-tar-bz2-tgz" class="headerlink" title="压缩(.tar.gz .tar.bz2 .tgz)"></a>压缩(.tar.gz .tar.bz2 .tgz)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar 参数 生成压缩包的名字 要压缩的文件或目录（中间用空格隔开）</span><br><span class="line"><span class="comment"># 使用gzip，标准后缀格式为：.tar.gz</span></span><br><span class="line"><span class="comment"># 使用bzip2，标准后缀格式为：.tar.bz2</span></span><br></pre></td></tr></table></figure><ul><li>c：创建压缩文件</li><li>z：使用gzip的方式进行文件压缩</li><li>j：使用bzip2的方式进行文件压缩</li><li>v：压缩过程中显示压缩信息</li><li>f：指定压缩包的名字</li></ul><blockquote><p>一般认为.tgz文件就等同于.tar.gz 文件。</p></blockquote><p>将config文件夹与b.txt文件以gzip的方式进行压缩，得到a.tar.gz这个压缩包。</p><p><img src="/pic/image-20240302203635419.png" alt="image-20240302203635419"></p><h4 id="解压缩-tar-gz-tar-bz2-tgz"><a href="#解压缩-tar-gz-tar-bz2-tgz" class="headerlink" title="解压缩(.tar.gz .tar.bz2 .tgz)"></a>解压缩(.tar.gz .tar.bz2 .tgz)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#解压到当前目前</span><br><span class="line">tar 参数 压缩包名</span><br><span class="line"></span><br><span class="line">#解压到指定目录中</span><br><span class="line">tar 参数 压缩包名 -C 解压目录</span><br></pre></td></tr></table></figure><ul><li>x：释放压缩文件内容</li><li>z：使用gzip的方式进行文件压缩，压缩包后缀为.tar.gz</li><li>j：使用bzip2的方式进行文件压缩，压缩包后缀为.tar.bz2</li><li>v：解压缩过程中显示信息</li><li>f：指定压缩包的名字</li></ul><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ubuntu</span></span><br><span class="line">sudo apt install zip</span><br><span class="line">sudo apt install unzip</span><br><span class="line"><span class="comment">#CentOS</span></span><br><span class="line">sudo yum install zip</span><br><span class="line">sudo yum install unzip</span><br></pre></td></tr></table></figure><h4 id="压缩-zip"><a href="#压缩-zip" class="headerlink" title="压缩(.zip)"></a>压缩(.zip)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip [-r] 压缩包名 要压缩的文件</span><br></pre></td></tr></table></figure><h4 id="解压缩-zip"><a href="#解压缩-zip" class="headerlink" title="解压缩(.zip)"></a>解压缩(.zip)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unzip 压缩包名</span><br><span class="line"><span class="comment"># 压缩到指定目录</span></span><br><span class="line">unzip 压缩包名 -d 解压目录</span><br></pre></td></tr></table></figure><h3 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ubuntu</span></span><br><span class="line">sudo apt install rar</span><br></pre></td></tr></table></figure><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>根据文件的属性，查找对应的磁盘文件，比如文件名，文件类型，文件大小，文件的目录深度等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">find 搜索的路径 参数 搜索的内容</span><br><span class="line"><span class="comment"># -name 文件名，支持通配符?（单个）和*（多个），如find ./ -name &quot;*.cpp&quot;</span></span><br><span class="line"><span class="comment"># -type 文件类型</span></span><br><span class="line"><span class="comment"># -size 文件大小</span></span><br><span class="line"></span><br><span class="line">find / -maxdepth 5 -name <span class="string">&quot;*.txt&quot;</span></span><br><span class="line"><span class="comment"># 搜索最多5层目录。同理还有 mindepth</span></span><br><span class="line"></span><br><span class="line">find 路径 参数 参数值 -<span class="built_in">exec</span> shell命令2 &#123;&#125; \;</span><br><span class="line"><span class="comment">#同时执行多个操作，将-exec替换为-ok，可以进行交互式操作。</span></span><br><span class="line"></span><br><span class="line">find 路径 参数 参数值 | xargs shell命令2</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20240303210053582.png" alt="image-20240303210053582"></p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep命令用于查找文件里符合条件的字符串。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;搜索的内容&quot;</span> 搜索的路径/文件 参数</span><br></pre></td></tr></table></figure><ul><li>-r：如果需要搜索目录。</li><li>-i：忽略大小写。</li><li>-n：显示行号。</li></ul><p><img src="/pic/image-20240303210754953.png" alt="image-20240303210754953"></p><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>功能与find类似，需要额外安装mlocate（ubuntu），不推荐。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++特性学习</title>
      <link href="/2024/03/15/C++%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/15/C++%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="const与constexpr"><a href="#const与constexpr" class="headerlink" title="const与constexpr"></a>const与constexpr</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>如果 <code>const</code> 变量的初始化值是常量表达式，那么它就是<strong>编译时常量</strong>。编译时常量使编译器能够执行非编译时常量无法提供的优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x &#123; <span class="number">3</span> &#125;;  <span class="comment">// x 是编译时常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y &#123; <span class="number">4</span> &#125;;  <span class="comment">// y 是编译时常量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; x + y; <span class="comment">// x + y 是编译时常量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器编译时，它可以计算x+y的值，并将其替换为7。</p><p>任何用非常量表达式初始化的 <code>const</code> 变量都是<strong>运行时常量</strong>。运行时常量是在运行时才知道其初始化值的常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> z&#123;<span class="built_in">sum</span>(x, y)&#125;; <span class="comment">//运行时常量</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>当使用 <code>const</code> 时，变量最终可能是编译时的 <code>const</code> 或运行时的 <code>const</code>，这取决于初始化式是否是常量表达式。</p><p><code>constexpr</code>变量<strong>只能是编译时常量</strong>。如果 <code>constexpr</code> 变量的初始化值不是常量表达式，编译器将出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x&#123;<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> y&#123;<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> z&#123;<span class="built_in">sum</span>(x, y)&#125;;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\23882\OneDrive\笔记\assets\image-20240312171839834.png" alt="image-20240312171839834"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/15/hello-world/"/>
      <url>/2024/03/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2023/12/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/12/30/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>进入到<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a>，点击20.10.0 LTS，下载Node.js。</p><p><img src="/pic/image-20231230164706281.png" alt="image-20231230164706281"></p><p>下载完成后，打开文件进行安装，全部使用默认配置即可。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在命令行中输入如下命令，出现版本号即为安装成功。</p><p><img src="/pic/image-20231230165804389.png" alt="image-20231230165804389"></p><p>这里推荐设置阿里的国内镜像，方便后续的下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><p>新建一个用于存放博客的文件夹，我这里是E:\code\Blog。在这个文件夹内打开命令行。</p><p>安装hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230170248355.png" alt="image-20231230170248355"></p><p>初始化，此处需要用管理员身份运行cmd，否则会报错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init .</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230170834292.png" alt="image-20231230170834292"></p><p>初始化完成后，文件夹内的结构如下</p><p><img src="/pic/image-20231230170908123.png" alt="image-20231230170908123"></p><p>然后依次输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建博客</span></span><br><span class="line">hexo new <span class="string">&quot;博客名&quot;</span></span><br><span class="line"><span class="comment"># 生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 打开本地服务器</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230171152376.png" alt="image-20231230171152376"></p><p>可以看到，hexo 正在运行，点击下面的网址即可进入到自己搭建的博客中。<a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><p>此时的博客部署在本地，只有本机能访问。想要所有人都能访问，我们需要利用Github Pages的功能。</p><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><h3 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h3><p>注册好一个github账号后，新建一个仓库。仓库的名字必须是 用户名.github.io，并且设置为Public</p><img src="/pic/image-20231230171535013.png" alt="image-20231230171535013" style="zoom:50%;" /><h3 id="推送到github"><a href="#推送到github" class="headerlink" title="推送到github"></a>推送到github</h3><p>修改配置文件_config.yml</p><p><img src="/pic/image-20231230171855053.png" alt="image-20231230171855053"></p><p>打开_config.yml后，拉到文件最下面。设置deploy，将repo设置成你创建的仓库即可。</p><p><img src="/pic/image-20231230180331594.png" alt="image-20231230180331594"></p><p>在配置好后，我们还需要进行一件事。</p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>将git与github账号绑定。打开git bash。输入如下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置用户名和邮箱</span></span><br><span class="line">git config --global user.name <span class="string">&quot;github 用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;github 注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230172750591.png" alt="image-20231230172750591"></p><p>然后生成ssh密钥文件。此前我已经生成过了，生成时直接一直回车就行了。然后打开文件所在的文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;github 注册邮箱&quot;</span></span><br></pre></td></tr></table></figure><p><img src="/pic/image-20231230172911732.png" alt="image-20231230172911732"></p><p><img src="/pic/image-20231230173010019.png" alt="image-20231230173010019"></p><p>接着，我们打开github-setting-keys的页面。生成一个新的SSH key。</p><p><img src="/pic/image-20231230173148579.png" alt="image-20231230173148579"></p><p>将id_rsa.pub的内容复制到key中，然后点击add，就成功添加了。</p><p><img src="/pic/image-20231230173309738.png" alt="image-20231230173309738"></p><h2 id="完成搭建"><a href="#完成搭建" class="headerlink" title="完成搭建"></a>完成搭建</h2><p>安装hexo-deployer-git</p><p><img src="/pic/image-20231230180102177.png" alt="image-20231230180102177"></p><p>最后重启hexo即可完成搭建。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h2><h3 id="购买"><a href="#购买" class="headerlink" title="购买"></a>购买</h3><p>首先购买一个域名，我这里是在阿里云购买。</p><p><a href="https://wanwang.aliyun.com/">阿里云企航_万网域名_商标注册_资质备案_软件著作权_网站建设-阿里云 (aliyun.com)</a></p><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>在github仓库新建一个CNAME文件，并且将你购买的域名填写进去后，提交修改。</p><p><img src="/pic/image-20231230181000266.png" alt="image-20231230181000266"></p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>添加两条记录</p><p><img src="/pic/image-20231230183246654.png" alt="image-20231230183246654"></p><p>等待10分钟后生效，可以直接通过你的域名进行访问。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
